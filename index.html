<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>カード型 L-システムジェネレータ (ダークモード)</title>
    
    <style>
        /* --- ダークモードのベース --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 10px; 
            background-color: #1e1e1e; 
            color: #d4d4d4; 
        }
        #app-container {
            display: flex;
            flex-direction: column; 
            max-width: 1600px; 
            margin: 0 auto;
            gap: 15px; 
            background-color: #252526; 
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
        }
        
        /* --- メインコンテンツエリア (3ペイン構造に変更) --- */
        #main-content {
            display: flex;
            gap: 15px;
            flex-grow: 1;
        }

        /* 1. 生成規則設定 (左ペイン - 固定幅) */
        #rule-editor-container {
            width: 380px; 
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-shrink: 0;
        }

        /* 2. パラメータ/パレット (中央ペイン - 縦長に変更) */
        #controls-and-palette {
            width: 250px; 
            display: flex;
            flex-direction: column; /* 縦積み */
            gap: 15px;
            flex-shrink: 0;
        }

        /* 3. メイン描画エリア (右ペイン) - 最大限に広がる */
        #drawing-area-container {
            flex-grow: 1; 
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        /* --- UIパーツのスタイル --- */
        #rule-editor, #parameters, #palette {
            padding: 12px; 
            border-radius: 6px;
            background-color: #3c3c3c; 
        }
        
        /* パラメータセクションを縦長でスクロール可能に */
        #parameters {
            flex-grow: 1;
            overflow-y: auto; 
            max-height: 100%; 
        }

        /* --- アンドゥ/リドゥボタンの縦並び化 --- */
        #editor-buttons {
            display: flex;
            flex-direction: column; 
            gap: 8px; 
            margin-bottom: 15px;
        }
        #editor-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* --- コマンドパレット --- */
        #palette h2 {
            font-size: 1.1em;
            border-bottom: none;
            margin-bottom: 8px;
        }
        #palette-cards {
            display: flex; 
            flex-wrap: wrap; 
            gap: 8px; 
        }

        /* --- プレビューエリア (左カラムの最下部に移動) --- */
        #preview-area {
            padding: 8px; /* パディングを少し小さく */
            border-radius: 6px;
            background-color: #3c3c3c;
            height: 250px; /* 適切な高さに設定 */
            margin-top: 15px; /* 上の要素との間隔 */
            flex-shrink: 0;
        }
        #preview-canvas {
            display: block;
            margin-top: 5px;
            border: 1px dashed #5a5a5a;
            width: 100%;
            height: 200px; /* プレビュー描画領域 */
            background-color: black; /* ⭐️ プレビュー背景を黒に */
        }


        /* --- メイン描画エリア --- */
        #main-canvas-wrapper {
            position: relative;
            width: 100%;
            padding-bottom: 75%; 
            height: 0;
            overflow: hidden;
            border: 1px solid #5a5a5a;
            border-radius: 4px;
            flex-grow: 1;
        }
        #main-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            cursor: grab; 
        }
        #main-canvas:active {
            cursor: grabbing;
        }
        
        /* --- ルールエディタ --- */
        .rule-set {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .rule-set .arrow {
            font-size: 1.5em;
            margin: 0 5px; /* マージンを詰める */
        }
        .rhs-rail {
            display: flex;
            gap: 3px; /* ギャップを詰める */
            flex-grow: 1;
            padding: 3px; /* パディングを詰める */
            border: 1px dashed #5a5a5a;
            border-radius: 4px;
            min-height: 50px; /* 高さを小さくする */
            align-items: center;
            flex-wrap: wrap; 
        }
        .rhs-card-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px; /* ギャップを詰める */
            position: relative; 
        }
        .rhs-card-container input.card-property {
            width: 35px; /* 入力幅を小さく */
            font-size: 0.6em; /* フォントを小さく */
            padding: 0px 2px;
            text-align: center;
            border: 1px solid #4a4a4a;
            background-color: #2e2e2e;
            color: #d4d4d4;
            border-radius: 3px;
        }

        /* --- カードのスタイル (サイズ調整) --- */
        .card, .lhs-card {
            display: inline-flex;
            flex-shrink: 0; 
            width: 40px; /* 幅を小さく */
            height: 40px; /* 高さを小さく */
            cursor: grab;
            border-radius: 6px; /* 角丸を小さく */
            font-weight: bold;
            font-size: 0.7em; /* フォントを小さく */
            text-align: center;
            user-select: none;
            color: transparent; 
            background-size: 70%; /* アイコンサイズも小さく */
            background-position: center;
            background-repeat: no-repeat;
            padding: 3px; 
            background-color: #3c3c3c; 
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .color-green { border: 2px solid #4caf50; } 
        .color-cyan { border: 2px solid #00bcd4; } 
        .color-magenta { border: 2px solid #e91e63; } 
        
        /* アイコン画像の再リンク */
        .card[data-command="F"], .lhs-card[data-command="F"] { background-image: url('command-f-draw.png'); }
        .card[data-command="f"] { background-image: url('command-f-move.png'); }
        .card[data-command="+"] { background-image: url('command-plus-right.png'); }
        .card[data-command="-"] { background-image: url('command-minus-left.png'); }
        .card[data-command="["], .lhs-card[data-command="["] { background-image: url('command-bracket-push.png'); }
        .card[data-command="]"] { background-image: url('command-bracket-pop.png'); }
        .card[data-command="X"], .lhs-card[data-command="X"] { background-image: url('command-x-variable.png'); }
        .card[data-command="Y"], .lhs-card[data-command="Y"] { background-image: url('command-y-variable.png'); }
        
        /* --- その他パーツ --- */
        #depth-controls { display: flex; align-items: center; gap: 5px; margin-bottom: 10px; }
        #generate-reset-buttons { display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px; } 
        .control-group { margin-top: 10px; padding-top: 10px; border-top: 1px solid #5a5a5a; }
        .zoom-controls { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }

        /* パフォーマンス制限機能のUI */
        .perf-limit-group { margin-top: 10px; padding-top: 10px; border-top: 1px solid #5a5a5a; }
        .perf-limit-group input { width: 60px; }
        .perf-limit-group small { display: block; margin-top: 5px; color: #888; font-size: 0.8em; }
    </style>
</head>
<body>
    <div id="app-container">
        
        <div id="main-content">

            <div id="rule-editor-container">
                <div id="rule-editor">
                    <h2>生成規則設定</h2>
                    
                    <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 15px;">
                        <label for="preset-select">プリセット:</label>
                        <select id="preset-select">
                            <option value="koch-curve">コッホ曲線 (基本)</option>
                            <option value="koch-snowflake">コッホ雪片 (閉)</option>
                            <option value="sierpinski-arrowhead">シェルピンスキー・アローヘッド</option>
                            <option value="dragon">ドラゴン曲線</option>
                            <option value="koch-island">コッホ・アイランド (四角)</option>
                            <option value="bush">ブッシュ/灌木 (植物)</option>
                            <option value="h-tree">H-Tree (木構造)</option>
                        </select>
                    </div>

                    <div id="editor-buttons"> 
                        <button id="undo-button" disabled>アンドゥ (Undo)</button>
                        <button id="redo-button" disabled>リドゥ (Redo)</button>
                        <button id="clear-all-button">全ルールクリア</button>
                        <button id="random-rule-button" style="background-color: #3f6e8c;">ランダムルール生成</button>
                    </div>
                    
                    <label for="axiom-input" style="display: block; margin-top: 10px;">初期値 (Axiom):</label>
                    <input type="text" id="axiom-input" value="F" style="width: 100px; margin-bottom: 10px;">

                    <div class="rule-set">
                        <div class="lhs-card color-green" data-command="F">F</div>
                        <div class="arrow">→</div>
                        <div class="rhs-rail" data-target="F" id="rhs-rail-f">
                            </div>
                    </div>

                    <div class="rule-set">
                        <div class="lhs-card color-cyan" data-command="X">X</div>
                        <div class="arrow">→</div>
                        <div class="rhs-rail" data-target="X" id="rhs-rail-x">
                            </div>
                    </div>
                    
                    <div class="rule-set">
                        <div class="lhs-card color-cyan" data-command="Y">Y</div>
                        <div class="arrow">→</div>
                        <div class="rhs-rail" data-target="Y" id="rhs-rail-y">
                            </div>
                    </div>
                </div>

                <div id="preview-area">
                    <h3>2世代プレビュー (1世代目:白, 2世代目:緑)</h3>
                    <canvas id="preview-canvas"></canvas>
                </div>
            </div>
            
            <div id="controls-and-palette">
                
                <div id="palette">
                    <h2>コマンドパレット (Drag me!)</h2>
                    <div id="palette-cards">
                        <div class="card color-green" data-command="F">F</div>
                        <div class="card color-green" data-command="+" data-angle="60">+</div>
                        <div class="card color-green" data-command="-" data-angle="60">-</div>
                        <div class="card color-magenta" data-command="f">f</div>
                        <div class="card color-magenta" data-command="]">]</div>
                        <div class="card color-cyan" data-command="[">[</div>
                        <div class="card color-cyan" data-command="X">X</div>
                        <div class="card color-cyan" data-command="Y">Y</div>
                    </div>
                </div>

                <div id="parameters">
                    <h3>描画パラメータ</h3>
                    <label for="depth">世代 (Depth): **(最大<span id="max-depth-limit">9</span>)**</label>
                    <div id="depth-controls">
                        <button id="depth-down">▼</button>
                        <span id="depth-value">0</span>
                        <button id="depth-up">▲</button>
                    </div>
                    
                    <div class="control-group">
                        <h3>線の太さ</h3>
                        <div id="line-width-options" style="display: flex; gap: 15px; margin-top: 5px;">
                            <label><input type="radio" name="lineWidth" value="fine"> 細</label>
                            <label><input type="radio" name="lineWidth" value="medium" checked> 中</label>
                            <label><input type="radio" name="lineWidth" value="bold"> 太</label>
                        </div>
                    </div>

                    <label for="angle">グローバル回転角 ($\delta$):</label>
                    <input type="range" id="angle-slider" min="1" max="180" value="60" step="0.1" style="width: 100%;">
                    <input type="number" id="angle-input" min="1" max="180" value="60" step="0.1" style="width: 80px;">
                    <button id="sync-angle-button">全カードに適用</button>
                    
                    <div class="control-group">
                        <h3>表示オプション</h3>
                        <div class="depth-color-option" style="margin-top: 10px;">
                            <input type="checkbox" id="color-by-depth" checked>
                            <label for="color-by-depth">世代ごとに色分け</label>
                        </div>
                        <div class="depth-color-option">
                            <input type="checkbox" id="keep-drawing">
                            <label for="keep-drawing">前の世代を残像表示</label>
                        </div>
                    </div>

                    <div class="perf-limit-group">
                        <h3>描画速度制限</h3>
                        <label for="target-draw-time">最大描画時間 (ms):</label>
                        <input type="number" id="target-draw-time" value="500" min="100" step="10">
                        <small>前回の描画時間: <span id="last-draw-time">0</span> ms</small>
                        <small>制限深度: <span id="limited-depth-info">適用なし</span></small>
                    </div>

                    
                    <div class="control-group">
                        <h3>ズーム &amp; パン</h3>
                        <label for="zoom-slider">ズーム倍率 (<span id="zoom-value">1.0</span>x):</label>
                        <div class="zoom-controls">
                            <input type="range" id="zoom-slider" min="0.1" max="10" value="1" step="0.1" style="flex-grow: 1;">
                            <button id="zoom-reset-button">リセット</button>
                        </div>
                        <div style="font-size: 0.8em; margin-top: 5px;">
                            (ホイールでズーム、ドラッグで移動)
                            <button id="pan-reset-button" style="padding: 2px 8px;">中央に戻す</button>
                        </div>
                    </div>

                    <div id="generate-reset-buttons">
                        <button id="reset-drawing-button" style="background-color: #5a5a5a;">描画リセット</button>
                    </div>
                </div>
            </div>

            <div id="drawing-area-container">
                <div id="drawing-area">
                    <h2>メイン描画 (世代: <span id="main-depth-display">0</span>)</h2>
                    <div id="main-canvas-wrapper">
                        <canvas id="main-canvas"></canvas>
                    </div>
                </div>
                </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // ===========================================
            // I. 状態管理と初期化
            // ===========================================
            const HISTORY_LIMIT = 20;
            const MAX_DEPTH_HARD_LIMIT = 15; // 物理的な最大値
            const history = [];
            let historyIndex = -1;
            
            const state = {
                depth: 0, 
                globalAngle: 60, 
                rules: { 'X': '', 'F': 'F+(60)F-(60)F-(60)F+(60)F', 'Y': '' }, // 初期ルールはダミー
                colorPalette: [
                    '#FF3F46', '#FFC82E', '#58D683', '#2E86C1', '#9B59B6', 
                    '#F39C12', '#1ABC9C', '#D98880', '#4A235A', '#FAD7A0', 
                    '#D35400', '#5D6D7E'  
                ],
                angleCommands: ['+', '-'],
                zoom: 1.0,           
                panX: 0,             
                panY: 0,
                // 新しいオプション
                lineWidthOption: 'medium', 
                // パフォーマンス計測用
                targetDrawTime: 500, // ms
                limitedDepth: MAX_DEPTH_HARD_LIMIT // パフォーマンス制限による現在の最大深度
            };
            
            let draggedElement = null;
            let isMoving = false; 

            // パン操作用の変数
            let isDraggingCanvas = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            
            const mainCanvas = document.getElementById('main-canvas');
            const previewCanvas = document.getElementById('preview-canvas');
            const undoButton = document.getElementById('undo-button');
            const redoButton = document.getElementById('redo-button');
            
            const mainCtx = mainCanvas.getContext('2d');
            const previewCtx = previewCanvas.getContext('2d');
            
            const depthValueSpan = document.getElementById('depth-value');
            const mainDepthDisplay = document.getElementById('main-depth-display');
            const angleSlider = document.getElementById('angle-slider');
            const angleInput = document.getElementById('angle-input');
            const rhsRails = Array.from(document.querySelectorAll('.rhs-rail'));
            const maxDepthLimitSpan = document.getElementById('max-depth-limit');
            const lastDrawTimeSpan = document.getElementById('last-draw-time');
            const limitedDepthInfoSpan = document.getElementById('limited-depth-info');
            const targetDrawTimeInput = document.getElementById('target-draw-time');

            const zoomSlider = document.getElementById('zoom-slider');
            const zoomValueSpan = document.getElementById('zoom-value');
            
            // 描画エリアのサイズをDOM要素から取得してcanvasに適用
            function resizeCanvas() {
                const mainWrapper = document.getElementById('main-canvas-wrapper');
                const prevWrapper = document.getElementById('preview-area'); // プレビューの親要素
                
                mainCanvas.width = mainWrapper.clientWidth;
                mainCanvas.height = mainWrapper.clientHeight; 
                
                // プレビューキャンバスの幅と高さを親要素に合わせて調整
                previewCanvas.width = prevWrapper.clientWidth - 16; // padding分を引く (8px * 2)
                previewCanvas.height = 200; // CSSで固定した高さ
                
                if (history.length > 0 || state.depth >= 0) { 
                    regenerateAndDraw(); 
                } else {
                    updatePreview();
                }
            }
            window.addEventListener('resize', resizeCanvas);


            // ===========================================
            // II. 履歴管理 (完全に実装)
            // ===========================================
            
            function updateHistoryButtons() {
                undoButton.disabled = historyIndex <= 0;
                redoButton.disabled = historyIndex >= history.length - 1;
            }

            function getCurrentStateForHistory() {
                return {
                    depth: state.depth,
                    globalAngle: state.globalAngle,
                    axiom: document.getElementById('axiom-input').value,
                    rules: getCurrentRules(),
                    zoom: state.zoom,
                    panX: state.panX,
                    panY: state.panY,
                    lineWidthOption: state.lineWidthOption 
                };
            }

            function loadStateFromHistory(savedState) {
                state.depth = savedState.depth;
                state.globalAngle = savedState.globalAngle;
                state.zoom = savedState.zoom;
                state.panX = savedState.panX;
                state.panY = savedState.panY;
                // 線の太さのオプションは履歴からロードし、デフォルト値'medium'をフォールバックとして使用
                state.lineWidthOption = savedState.lineWidthOption || 'medium'; 
                
                // UIの更新
                document.getElementById('axiom-input').value = savedState.axiom;
                updateAngle(savedState.globalAngle, false); 
                updateZoom(savedState.zoom, false); 
                updateDepth(savedState.depth, false); 

                // 線の太さのラジオボタンを更新
                const lineWidthRadio = document.querySelector(`input[name="lineWidth"][value="${state.lineWidthOption}"]`);
                if(lineWidthRadio) lineWidthRadio.checked = true;


                // ルールをDOMに反映
                const railF = document.getElementById('rhs-rail-f');
                const railX = document.getElementById('rhs-rail-x');
                const railY = document.getElementById('rhs-rail-y'); 
                
                applyRulesToRail(railF, savedState.rules.F || '', savedState.globalAngle);
                applyRulesToRail(railX, savedState.rules.X || '', savedState.globalAngle);
                applyRulesToRail(railY, savedState.rules.Y || '', savedState.globalAngle);

                regenerateAndDraw();
                updatePreview();
                updateHistoryButtons();
            }

            function saveHistory() {
                // ... (履歴保存ロジックは変更なし) ...
                if (historyIndex < history.length - 1) {
                    history.splice(historyIndex + 1);
                }
                
                const currentState = getCurrentStateForHistory();
                history.push(currentState);
                historyIndex = history.length - 1;

                if (history.length > HISTORY_LIMIT) {
                    history.shift();
                    historyIndex--;
                }
                updateHistoryButtons();
            }
            
            undoButton.addEventListener('click', () => {
                if (historyIndex > 0) {
                    historyIndex--;
                    loadStateFromHistory(history[historyIndex]);
                }
            });
            
            redoButton.addEventListener('click', () => {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    loadStateFromHistory(history[historyIndex]);
                }
            });

            // ===========================================
            // III. UIコントロールと描画トリガー
            // ===========================================

            /**
             * 描画に必要なオートスケールとオートパンを計算する
             */
            function calculateAutoTransform(lSystemString, currentDepth, canvasWidth, canvasHeight) {
                const rules = getCurrentRules();
                // 'F'の置換規則に含まれる 'F' または 'f' の数を取得
                const F_rule_Ff_count = (rules['F'] ? (rules['F'].match(/[Ff]/g) || []).length : 1);
                const F_multiplier = F_rule_Ff_count > 0 ? F_rule_Ff_count : 1;
                
                // 動的線分長を計算: 世代が上がるごとに、描画される図形の実サイズが一定になるように調整
                const dynamicLineLength = 1.0 / Math.pow(F_multiplier, currentDepth); 
                
                // この動的線分長を使用してバウンディングボックスを計算 (実サイズ)
                const actualBounds = getLSystemBounds(lSystemString, state.globalAngle, dynamicLineLength);
                
                const targetRatio = 0.9; // 画面の90%を使用
                const targetWidth = canvasWidth * targetRatio;
                const targetHeight = canvasHeight * targetRatio;
                
                let autoScale = 1.0;
                
                if (actualBounds.width > 0 && actualBounds.height > 0) {
                     // 実際のバウンディングボックスサイズを画面に収めるためのスケール
                     autoScale = Math.min(targetWidth / actualBounds.width, targetHeight / actualBounds.height);
                } else if (lSystemString.match(/[Ff]/g)) {
                    // F,fはあるがバウンズが0の場合（直線など）。適当な初期ズームを設定
                    autoScale = Math.min(canvasWidth, canvasHeight) * 0.5;
                } else {
                    autoScale = 1.0; // 描画要素がない場合
                }
                
                // オートパン計算 (中央揃え)
                const autoPanX = canvasWidth / 2 - (actualBounds.width * autoScale) / 2 - actualBounds.minX * autoScale;
                const autoPanY = canvasHeight / 2 - (actualBounds.height * autoScale) / 2 - actualBounds.minY * autoScale;

                return { autoScale, autoPanX, autoPanY, bounds: actualBounds, dynamicLineLength };
            }

            // 描画機能の本体。全パラメーターの変更はこの関数をコールする
            function regenerateAndDraw() {
                const startTime = performance.now(); // 計測開始
                
                const axiom = document.getElementById('axiom-input').value;
                const iterations = state.depth;
                state.rules = getCurrentRules();
                
                mainDepthDisplay.textContent = iterations;
                
                const lSystemStrings = generateLSystemWithDepth(axiom, state.rules, iterations);
                drawLSystem(mainCtx, lSystemStrings, true);

                const endTime = performance.now(); // 計測終了
                const drawTime = (endTime - startTime).toFixed(2);
                lastDrawTimeSpan.textContent = drawTime;
                
                // パフォーマンス制限のチェックと適用
                checkAndLimitDepth(drawTime);
            }

            /**
             * 世代の更新。ユーザー操作か履歴ロードかでsaveHistoryを制御
             */
            const updateDepth = (newDepth, shouldSave = true) => {
                const actualMaxDepth = Math.min(MAX_DEPTH_HARD_LIMIT, state.limitedDepth);
                state.depth = Math.min(Math.max(newDepth, 0), actualMaxDepth); 
                depthValueSpan.textContent = state.depth;
                mainDepthDisplay.textContent = state.depth;
                maxDepthLimitSpan.textContent = actualMaxDepth;
                
                regenerateAndDraw(); 
                if (shouldSave) saveHistory();
            };
            
            document.getElementById('depth-up').addEventListener('click', () => { updateDepth(state.depth + 1); });
            document.getElementById('depth-down').addEventListener('click', () => { updateDepth(state.depth - 1); });
            
            // 描画時間制限の更新
            targetDrawTimeInput.addEventListener('change', (e) => {
                state.targetDrawTime = parseInt(e.target.value);
                // 新しい制限時間で再チェック
                checkAndLimitDepth(parseFloat(lastDrawTimeSpan.textContent));
                updateDepth(state.depth, true); // 深度を再調整
            });

            /**
             * 描画時間に基づいて深度の上限を自動調整する
             */
            function checkAndLimitDepth(lastDrawTime) {
                const F_rule_Ff_count = (getCurrentRules()['F'] ? (getCurrentRules()['F'].match(/[Ff]/g) || []).length : 1);
                const F_multiplier = F_rule_Ff_count > 0 ? F_rule_Ff_count : 1;
                
                // F->F などの変化がない場合は処理しない
                if (F_multiplier <= 1 && state.depth < MAX_DEPTH_HARD_LIMIT) {
                    state.limitedDepth = MAX_DEPTH_HARD_LIMIT;
                    limitedDepthInfoSpan.textContent = `適用なし (乗数 ${F_multiplier.toFixed(1)}x)`;
                    maxDepthLimitSpan.textContent = MAX_DEPTH_HARD_LIMIT;
                    return;
                }
                
                let newLimitedDepth = MAX_DEPTH_HARD_LIMIT;
                
                // ターゲットタイムを超えた場合
                if (lastDrawTime > state.targetDrawTime && state.depth > 0) {
                    const timeRatio = lastDrawTime / state.targetDrawTime;
                    const logRatio = Math.log(timeRatio) / Math.log(F_multiplier);
                    newLimitedDepth = Math.max(1, Math.floor(state.depth - logRatio));
                    
                    limitedDepthInfoSpan.textContent = `深度 ${newLimitedDepth}`;
                    state.limitedDepth = newLimitedDepth;

                } else if (lastDrawTime * F_multiplier < state.targetDrawTime && state.depth < MAX_DEPTH_HARD_LIMIT) {
                    // ターゲットタイムよりも十分速い場合
                    if (lastDrawTime * F_multiplier < state.targetDrawTime) {
                        newLimitedDepth = Math.min(MAX_DEPTH_HARD_LIMIT, state.depth + 1);
                        limitedDepthInfoSpan.textContent = `余裕あり (推定: ${(lastDrawTime * F_multiplier).toFixed(0)} ms)`;
                        state.limitedDepth = newLimitedDepth;
                    }
                    
                } else if (lastDrawTime <= state.targetDrawTime) {
                    // 制限時間内に収まっている場合、現在の深度を上限としない
                    state.limitedDepth = MAX_DEPTH_HARD_LIMIT;
                    limitedDepthInfoSpan.textContent = "適用なし";
                }
                
                maxDepthLimitSpan.textContent = state.limitedDepth;

                if (state.depth > state.limitedDepth) {
                    state.depth = state.limitedDepth;
                    depthValueSpan.textContent = state.depth;
                    mainDepthDisplay.textContent = state.depth;
                }
            }


            // 角度の更新と即時描画
            const updateAngle = (value, shouldSave = true) => {
                state.globalAngle = parseFloat(value);
                angleSlider.value = state.globalAngle;
                angleInput.value = state.globalAngle;
                updatePreview();
                regenerateAndDraw(); 
                if (shouldSave) saveHistory();
            };
            angleSlider.addEventListener('input', (e) => updateAngle(e.target.value, false)); 
            angleSlider.addEventListener('change', (e) => saveHistory()); 

            angleInput.addEventListener('change', (e) => { updateAngle(e.target.value); });

            document.getElementById('sync-angle-button').addEventListener('click', () => {
                rhsRails.forEach(rail => {
                    rail.querySelectorAll('.card[data-angle]').forEach(card => {
                        const input = card.parentNode.querySelector('.card-property');
                        if (input) {
                            input.value = state.globalAngle;
                            card.dataset.angle = state.globalAngle;
                        }
                    });
                });
                saveHistory(); 
                updatePreview();
                regenerateAndDraw(); 
            });
            
            document.getElementById('axiom-input').addEventListener('change', () => {
                saveHistory();
                regenerateAndDraw(); 
            });
            
            document.getElementById('reset-drawing-button').addEventListener('click', () => {
                mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
                mainDepthDisplay.textContent = state.depth; 
            });

            // ズーム操作の処理
            const updateZoom = (value, shouldSave = true) => {
                state.zoom = parseFloat(value);
                zoomSlider.value = state.zoom;
                zoomValueSpan.textContent = state.zoom.toFixed(1);
                regenerateAndDraw(); 
                if (shouldSave) saveHistory();
            };

            zoomSlider.addEventListener('input', (e) => updateZoom(e.target.value, false));
            zoomSlider.addEventListener('change', (e) => saveHistory());

            document.getElementById('zoom-reset-button').addEventListener('click', () => {
                updateZoom(1.0);
                document.getElementById('pan-reset-button').click(); 
            });

            // パンリセットボタンの処理
            document.getElementById('pan-reset-button').addEventListener('click', () => {
                state.panX = 0;
                state.panY = 0;
                regenerateAndDraw(); 
                saveHistory();
            });

            // ホイールズーム機能
            mainCanvas.addEventListener('wheel', (e) => {
                e.preventDefault(); 
                
                const zoomFactor = 1.1; 
                let newZoom = state.zoom;

                if (e.deltaY < 0) { newZoom *= zoomFactor; } 
                else { newZoom /= zoomFactor; }
                
                newZoom = Math.min(Math.max(newZoom, 0.1), 10);

                const rect = mainCanvas.getBoundingClientRect();
                
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const currentAxiom = document.getElementById('axiom-input').value;
                const lSystemString = generateLSystemWithDepth(currentAxiom, getCurrentRules(), state.depth).pop();
                
                const { autoScale, autoPanX, autoPanY } = calculateAutoTransform(lSystemString, state.depth, mainCanvas.width, mainCanvas.height);

                const currentFinalScale = autoScale * state.zoom;
                const currentFinalPanX = autoPanX + state.panX;
                const currentFinalPanY = autoPanY + state.panY;

                const L_system_X = (mouseX - currentFinalPanX) / currentFinalScale;
                const L_system_Y = (mouseY - currentFinalPanY) / currentFinalScale;
                
                const newFinalScale = autoScale * newZoom;
                
                state.panX = mouseX - autoPanX - (L_system_X * newFinalScale);
                state.panY = mouseY - autoPanY - (L_system_Y * newFinalScale);

                updateZoom(newZoom); 
                saveHistory();
            });


            // パン操作 (マウスドラッグ) の処理
            mainCanvas.addEventListener('mousedown', (e) => {
                isDraggingCanvas = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                mainCanvas.style.cursor = 'grabbing';
            });

            mainCanvas.addEventListener('mousemove', (e) => {
                if (!isDraggingCanvas) return;
                
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                state.panX += deltaX;
                state.panY += deltaY;

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                regenerateAndDraw(); 
            });

            mainCanvas.addEventListener('mouseup', () => {
                if(isDraggingCanvas) {
                    isDraggingCanvas = false;
                    mainCanvas.style.cursor = 'grab';
                    saveHistory();
                }
            });
            
            mainCanvas.addEventListener('mouseleave', () => {
                isDraggingCanvas = false;
                mainCanvas.style.cursor = 'grab';
            });
            
            // ===========================================
            // IV. プリセット機能 (拡張)
            // ===========================================
            
            // ⭐️ プリセットを拡張
            const presets = {
                // 1. コッホ曲線とその変形
                "koch-curve": { axiom: 'F', rules: { F: 'F-(60)F++(60)F-(60)F', X: '', Y: '' }, angle: 60, depth: 4, lineWidthOption: 'medium' }, 
                "koch-snowflake": { axiom: 'F++F++F', rules: { F: 'F-(60)F++(60)F-(60)F', X: '', Y: '' }, angle: 60, depth: 4, lineWidthOption: 'medium' },
                "koch-island": { axiom: 'F+F+F+F', rules: { F: 'F-(90)F+(90)F+(90)F-(90)F', X: '', Y: '' }, angle: 90, depth: 3, lineWidthOption: 'medium' },

                // 2. シェルピンスキー曲線とその変形
                "sierpinski-arrowhead": { axiom: 'F', rules: { F: 'X+(60)F+(60)X', X: 'F-(60)X-(60)F', Y: '' }, angle: 60, depth: 5, lineWidthOption: 'medium' },
                
                // 3. 複雑なフラクタル
                "dragon": { axiom: 'FX', rules: { F: 'F', X: 'X+(90)YF+', Y: '-(90)FX-Y' }, angle: 90, depth: 9, lineWidthOption: 'fine' }, 

                // 4. 植物と木構造
                "bush": { axiom: 'X', rules: { F: 'FF', X: 'F[+(25)X][-(25)X]F[-(25)X]+(25)X', Y: '' }, angle: 25, depth: 6, lineWidthOption: 'fine' },
                "h-tree": { axiom: 'F', rules: { F: 'F[+(90)F][-(90)F]', X: '', Y: '' }, angle: 90, depth: 4, lineWidthOption: 'medium' }
            };
            
            function applyRulesToRail(railElement, ruleString, defaultAngle) {
                railElement.innerHTML = '';
                // 'F', 'X', 'Y', 'f', '+', '-', '[', ']' および角度表記を抽出
                const tokens = ruleString.match(/([+\-])\(\d+(\.\d+)?\)|[FXfY[\]+\-]/g) || [];
                
                tokens.forEach(token => {
                    let command = token;
                    let angle = defaultAngle;

                    const angleMatch = token.match(/^([+\-])\((\d+(\.\d+)?)\)$/);
                    if (angleMatch) {
                        command = angleMatch[1];
                        angle = angleMatch[2];
                    }

                    const container = createCardContainer(command, angle);
                    railElement.appendChild(container);
                });
            }

            function applyPreset(presetName) {
                const preset = presets[presetName];
                if (!preset) return;

                document.getElementById('axiom-input').value = preset.axiom;
                updateAngle(preset.angle, false); 
                updateDepth(preset.depth, false); 
                
                // 線の太さもプリセットから適用
                state.lineWidthOption = preset.lineWidthOption || 'medium'; 
                const lineWidthRadio = document.querySelector(`input[name="lineWidth"][value="${state.lineWidthOption}"]`);
                if(lineWidthRadio) lineWidthRadio.checked = true;

                
                const railF = document.getElementById('rhs-rail-f');
                const railX = document.getElementById('rhs-rail-x');
                const railY = document.getElementById('rhs-rail-y'); 
                
                applyRulesToRail(railF, preset.rules.F || '', preset.angle);
                applyRulesToRail(railX, preset.rules.X || '', preset.angle);
                applyRulesToRail(railY, preset.rules.Y || '', preset.angle);

                state.zoom = 1.0;
                state.panX = 0;
                state.panY = 0;
                
                state.limitedDepth = MAX_DEPTH_HARD_LIMIT;
                
                saveHistory();
                updatePreview();
                regenerateAndDraw(); 
            }
            
            document.getElementById('preset-select').addEventListener('change', (e) => {
                applyPreset(e.target.value);
            });

            // ===========================================
            // V. カード/ルールロジック (変更なし)
            // ===========================================
            
            function getCardColorClass(command) {
                if (command === 'F' || command === '+' || command === '-') return 'color-green';
                if (command === '[' || command === 'X' || command === 'Y') return 'color-cyan';
                if (command === 'f' || command === ']') return 'color-magenta';
                return '';
            }
            
            function createCardContainer(command, angle) {
                const container = document.createElement('div');
                container.classList.add('rhs-card-container');
                container.setAttribute('draggable', true); 
                
                const card = document.createElement('div');
                card.classList.add('card', getCardColorClass(command));
                card.textContent = command;
                card.dataset.command = command;
                card.style.cursor = 'grab';
                
                container.appendChild(card);
                
                if (state.angleCommands.includes(command)) {
                    card.dataset.angle = angle || state.globalAngle;
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.classList.add('card-property');
                    input.value = card.dataset.angle;
                    input.min = 1; input.max = 180; input.step = 0.1;
                    
                    input.addEventListener('change', (e) => {
                        card.dataset.angle = e.target.value;
                        saveHistory(); 
                        updatePreview();
                        regenerateAndDraw(); 
                    });
                    container.appendChild(input);
                }

                container.addEventListener('dblclick', () => { container.remove(); saveHistory(); updatePreview(); regenerateAndDraw(); }); 
                
                container.addEventListener('dragstart', (e) => {
                    draggedElement = e.currentTarget;
                    isMoving = true;
                    e.dataTransfer.effectAllowed = 'move';
                });
                container.addEventListener('dragend', () => {
                    if (isMoving) {
                        saveHistory();
                        updatePreview();
                        regenerateAndDraw(); 
                    }
                    draggedElement = null;
                    isMoving = false;
                    document.querySelectorAll('.drop-indicator').forEach(i => i.remove());
                });
                
                return container;
            }
            
            document.getElementById('clear-all-button').addEventListener('click', () => {
                rhsRails.forEach(rail => rail.innerHTML = '');
                document.getElementById('axiom-input').value = 'F';
                saveHistory();
                updatePreview();
                regenerateAndDraw(); 
            });
            
            // ⭐️ 改善点: スマートなランダムルール生成関数
            function generateSmartRHS(targetCommand, maxLength, globalAngle) {
                const angleCommands = ['+', '-'];
                let bracketBalance = 0;
                let rhs = '';
                
                const getTurnCommand = () => angleCommands[Math.floor(Math.random() * 2)];
                const getRandomCommand = (commands) => commands[Math.floor(Math.random() * commands.length)];

                // 1. Mandatory Core Components
                let coreElements = [];
                
                if (targetCommand === 'F') {
                    // Fルール: 描画と回転は必須、変数(再帰)を導入
                    coreElements.push('F');
                    coreElements.push(getTurnCommand());
                    coreElements.push('F'); 
                    if (Math.random() < 0.6) coreElements.push(getRandomCommand(['X', 'Y', 'F'])); // 自己再帰 or 変数導入
                    coreElements.push(getTurnCommand());
                } else if (targetCommand === 'X' || targetCommand === 'Y') {
                    // X/Yルール: 描画と枝分かれ(再帰)は必須
                    coreElements.push(getRandomCommand(['F', 'f'])); // Draw/move command
                    
                    // Branch 1: Recursion
                    coreElements.push('['); bracketBalance++;
                    coreElements.push(getTurnCommand());
                    coreElements.push(targetCommand); // Recursion
                    coreElements.push(']'); bracketBalance--;
                    
                    // Branch 2: Complexity
                    if (Math.random() < 0.8) {
                        coreElements.push(getTurnCommand());
                        coreElements.push('['); bracketBalance++;
                        coreElements.push(targetCommand); // Recursion
                        coreElements.push(getTurnCommand());
                        coreElements.push(']'); bracketBalance--;
                    }
                }
                
                // 2. Build the initial string from core elements
                rhs = coreElements.join('');

                // 3. Fill the rest randomly
                const fillCommands = ['F', 'f', '+', '-', '[', ']', 'X', 'Y']; 
                const remainingLength = Math.max(0, maxLength - rhs.length);
                
                for (let i = 0; i < remainingLength; i++) {
                    let command = getRandomCommand(fillCommands);
                    
                    if (command === '[') {
                        if (bracketBalance < 3) { 
                            rhs += command;
                            bracketBalance++;
                        }
                    } else if (command === ']') {
                        if (bracketBalance > 0) {
                            rhs += command;
                            bracketBalance--;
                        }
                    } else if (angleCommands.includes(command)) {
                         // ランダム要素で角度コマンドが出た場合は、強制的に一つ前のコマンドを挿入してバランスを取る
                         rhs += getTurnCommand();
                    } else {
                        rhs += command;
                    }
                }
                
                // 4. Final bracket balancing
                while (bracketBalance > 0) {
                    rhs += ']';
                    bracketBalance--;
                }
                
                // 5. Apply angles to '+' and '-'
                let finalRHS = '';
                for(const char of rhs) {
                    if (angleCommands.includes(char)) {
                        finalRHS += `${char}(${globalAngle})`;
                    } else {
                        finalRHS += char;
                    }
                }
                
                return finalRHS;
            }

            document.getElementById('random-rule-button').addEventListener('click', () => {
                // ⭐️ 改善点1: 代表的なフラクタル角度から選択
                const FRACTAL_ANGLES = [90, 60, 45, 30, 22.5, 120, 18];
                const randomGlobalAngle = FRACTAL_ANGLES[Math.floor(Math.random() * FRACTAL_ANGLES.length)];
                
                updateAngle(randomGlobalAngle, false);
                
                // ⭐️ 改善点2: より複雑なルールを生成するため、最大長を12に設定
                const MAX_RULE_LENGTH = 12;

                const initialAxiom = ['F', 'X', 'FX', 'X+F', 'Y'].sort(() => 0.5 - Math.random())[0];
                document.getElementById('axiom-input').value = initialAxiom;

                // ⭐️ 改善点3: スマートなルール生成関数を使用し、ルールの長さをランダムに決定
                const randomRules = {
                    F: generateSmartRHS('F', Math.floor(Math.random() * (MAX_RULE_LENGTH - 5)) + 5, randomGlobalAngle),
                    X: generateSmartRHS('X', Math.floor(Math.random() * (MAX_RULE_LENGTH - 5)) + 5, randomGlobalAngle),
                    Y: generateSmartRHS('Y', Math.floor(Math.random() * (MAX_RULE_LENGTH - 5)) + 5, randomGlobalAngle)
                };
                
                applyRulesToRail(document.getElementById('rhs-rail-f'), randomRules.F, randomGlobalAngle);
                applyRulesToRail(document.getElementById('rhs-rail-x'), randomRules.X, randomGlobalAngle);
                applyRulesToRail(document.getElementById('rhs-rail-y'), randomRules.Y, randomGlobalAngle);

                // ⭐️ 改善点4: 初期深度を3に設定
                updateDepth(3, false); 
                
                saveHistory();
                updatePreview();
                regenerateAndDraw(); 
            });


            function getCurrentRules() { 
                const rules = {};
                rhsRails.forEach(rail => {
                    const target = rail.dataset.target; 
                    let rhsString = '';
                    Array.from(rail.querySelectorAll('.card')).forEach(card => {
                        const command = card.dataset.command;
                        let angle = card.dataset.angle;
                        if (state.angleCommands.includes(command)) {
                            rhsString += `${command}(${angle})`;
                        } else {
                            rhsString += command;
                        }
                    });
                    if (target) { rules[target] = rhsString; }
                });
                return rules;
            }
            
            function generateLSystemWithDepth(axiom, rules, iterations) { 
                let currentStrings = [axiom];
                let allStrings = [axiom];
                for (let i = 0; i < iterations; i++) {
                    let nextString = '';
                    if (currentStrings[i].length > 1000000) { 
                        console.warn(`Depth ${i+1} exceeds string length limit. Stopping generation.`);
                        return allStrings;
                    }
                    for (const char of currentStrings[i]) {
                        if (Object.prototype.hasOwnProperty.call(rules, char)) { nextString += rules[char]; } 
                        else { nextString += char; }
                    }
                    currentStrings.push(nextString);
                    allStrings.push(nextString);
                }
                return allStrings;
            }

            // VI. オートスケールとバウンディングボックス計算
            function getLSystemBounds(lSystemString, globalAngle, lineLength) { 
                let x = 0;
                let y = 0;
                let currentAngle = -90; 
                const stateStack = [];

                let minX = 0, maxX = 0, minY = 0, maxY = 0;

                for (let i = 0; i < lSystemString.length; i++) {
                    const command = lSystemString[i];
                    let turnAngle = globalAngle; 

                    if (state.angleCommands.includes(command)) {
                        const angleMatch = lSystemString.substring(i).match(/^([+\-])\((\d+(\.\d+)?)\)/);
                        if (angleMatch) {
                            turnAngle = parseFloat(angleMatch[2]);
                            i += angleMatch[0].length - 1; 
                        }
                    }

                    switch (command) {
                        case 'F': 
                        case 'f': 
                            const dx = lineLength * Math.cos(currentAngle * Math.PI / 180);
                            const dy = lineLength * Math.sin(currentAngle * Math.PI / 180);
                            x += dx;
                            y += dy;
                            
                            minX = Math.min(minX, x);
                            maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y);
                            maxY = Math.max(maxY, y);
                            break;
                        case '+': currentAngle += turnAngle; break;
                        case '-': currentAngle -= turnAngle; break;
                        case '[': stateStack.push({ x, y, angle: currentAngle }); break;
                        case ']': 
                            const stateRestored = stateStack.pop();
                            if (stateRestored) {
                                x = stateRestored.x;
                                y = stateRestored.y;
                                currentAngle = stateRestored.angle;
                            }
                            break;
                    }
                }

                return {
                    width: maxX - minX,
                    height: maxY - minY,
                    minX: minX,
                    minY: minY
                };
            }
            
            /**
             * 選択された線の太さオプションに基づいたベースライン幅を取得する
             */
            function getBaseLineWidth() {
                switch (state.lineWidthOption) {
                    case 'fine': return 1.0;
                    case 'medium': return 2.0;
                    case 'bold': return 3.5; 
                    default: return 2.0;
                }
            }


            // VII. ズームとパンを考慮した描画ロジック
            function drawLSystem(ctx, lSystemStrings, isMainCanvas) { 
                const iterations = lSystemStrings.length - 1;
                const lSystemString = lSystemStrings[iterations];
                
                // --- メインキャンバスの描画 ---
                if (isMainCanvas) {
                    // 1. オートスケールとオートパンを計算
                    const { autoScale, autoPanX, autoPanY, bounds, dynamicLineLength } = calculateAutoTransform(lSystemString, iterations, mainCanvas.width, mainCanvas.height);
                    
                    const startBaseX = 0; 
                    const startBaseY = 0;

                    // 2. 最終変換の計算
                    const finalZoom = autoScale * state.zoom;
                    const finalPanX = autoPanX + state.panX;
                    const finalPanY = autoPanY + state.panY;
                    
                    // 3. 描画実行
                    performDrawing(ctx, lSystemStrings, isMainCanvas, finalZoom, finalPanX, finalPanY, startBaseX, startBaseY, bounds, dynamicLineLength);
                    
                } else {
                    // --- プレビュー描画ロジック (Depth 1と2を使用) ---
                    
                    // 1世代目の文字列を使ってバウンディングボックスを計算 (Depth 1)
                    const previewStringForBounds = lSystemStrings[Math.min(1, lSystemStrings.length - 1)]; 
                    const previewBounds = getLSystemBounds(previewStringForBounds, state.globalAngle, 1.0);
                    
                    const targetRatio = 0.9;
                    const targetWidth = previewCtx.canvas.width * targetRatio;
                    const targetHeight = previewCtx.canvas.height * targetRatio;
                    let autoScale = 1.0;
                    
                    if (previewBounds.width > 0 && previewBounds.height > 0) {
                        autoScale = Math.min(targetWidth / previewBounds.width, targetHeight / previewBounds.height);
                    } else {
                        autoScale = Math.min(previewCtx.canvas.width, previewCtx.canvas.height) * 0.5;
                    }
                    
                    const previewPanX = previewCtx.canvas.width / 2 - (previewBounds.width * autoScale) / 2 - previewBounds.minX * autoScale;
                    const previewPanY = previewCtx.canvas.height / 2 - (previewBounds.height * autoScale) / 2 - previewBounds.minY * autoScale;


                    // プレビュー描画実行
                    performDrawing(ctx, lSystemStrings, false, autoScale, previewPanX, previewPanY, 0, 0, previewBounds, 1.0);
                }
            }

            // 実際の描画を実行するコア関数
            function performDrawing(ctx, lSystemStrings, isMainCanvas, scale, panX, panY, startBaseX, startBaseY, bounds, baseLineLength) {
                const iterations = lSystemStrings.length - 1;
                const colorByDepth = document.getElementById('color-by-depth').checked;
                const keepDrawing = document.getElementById('keep-drawing').checked;
                
                const baseWidth = getBaseLineWidth(); 

                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); 
                
                // ⭐️ 修正: 描画する世代の範囲を決定
                const startDepth = isMainCanvas ? (keepDrawing ? 0 : iterations) : Math.min(1, iterations); 
                const endDepth = isMainCanvas ? iterations : Math.min(2, iterations); 
                
                const rules = getCurrentRules();
                const F_rule_Ff_count = (rules['F'] ? (rules['F'].match(/[Ff]/g) || []).length : 1);
                const F_multiplier = F_rule_Ff_count > 0 ? F_rule_Ff_count : 1;

                for (let depth = startDepth; depth <= endDepth; depth++) {
                    const lSystemString = lSystemStrings[depth];
                    
                    let x = startBaseX;
                    let y = startBaseY;
                    let currentAngle = -90; 
                    const stateStack = [];

                    const lineLength = 1.0 / Math.pow(F_multiplier, depth);
                    
                    // --- 線幅と色の設定 ---
                    if (isMainCanvas) {
                        // メインキャンバスの線幅ロジック (ズーム対応)
                        ctx.lineWidth = Math.max(0.5, baseWidth / scale) * (isMainCanvas ? 1 : 0.5); 
                        
                        if (colorByDepth) {
                            ctx.strokeStyle = state.colorPalette[depth % state.colorPalette.length];
                        } else {
                            ctx.strokeStyle = 'white'; 
                        }
                        if (keepDrawing && depth < iterations) {
                            ctx.globalAlpha = 0.2 + (0.8 / iterations) * depth; 
                        } else {
                            ctx.globalAlpha = 1.0;
                        }
                    } else {
                        // ⭐️ プレビューの線幅と色
                        ctx.lineWidth = 2.5; // 線の太さを固定で太く
                        ctx.globalAlpha = 1.0;

                        if (depth === 1) {
                            ctx.strokeStyle = '#ffffff'; // 1世代目 (Depth 1) は白
                        } else if (depth === 2) {
                            ctx.strokeStyle = '#4caf50'; // 2世代目 (Depth 2) は緑
                        } else {
                            continue; // Depth 0はスキップ
                        }
                    }

                    // --- 描画開始 ---
                    ctx.beginPath();
                    ctx.moveTo(x * scale + panX, y * scale + panY); 
                    
                    for (let i = 0; i < lSystemString.length; i++) {
                        const command = lSystemString[i];
                        let turnAngle = state.globalAngle; 

                        if (state.angleCommands.includes(command)) {
                            const angleMatch = lSystemString.substring(i).match(/^([+\-])\((\d+(\.\d+)?)\)/);
                            if (angleMatch) {
                                turnAngle = parseFloat(angleMatch[2]);
                                i += angleMatch[0].length - 1; 
                            }
                        }

                        switch (command) {
                            case 'F': 
                            case 'f': 
                                const dx = lineLength * Math.cos(currentAngle * Math.PI / 180);
                                const dy = lineLength * Math.sin(currentAngle * Math.PI / 180);
                                const newX = x + dx;
                                const newY = y + dy;
                                
                                if (command === 'F') {
                                    ctx.lineTo(newX * scale + panX, newY * scale + panY);
                                    ctx.stroke();
                                    ctx.beginPath();
                                    ctx.moveTo(newX * scale + panX, newY * scale + panY);
                                } else {
                                    ctx.moveTo(newX * scale + panX, newY * scale + panY);
                                }
                                x = newX;
                                y = newY;
                                break;
                            case '+': currentAngle += turnAngle; break;
                            case '-': currentAngle -= turnAngle; break;
                            case '[': stateStack.push({ x, y, angle: currentAngle }); break;
                            case ']': 
                                const stateRestored = stateStack.pop();
                                if (stateRestored) {
                                    x = stateRestored.x;
                                    y = stateRestored.y;
                                    currentAngle = stateRestored.angle;
                                    ctx.beginPath();
                                    ctx.moveTo(x * scale + panX, y * scale + panY); 
                                }
                                break;
                        }
                    }
                }
            }


            // --- プレビュー描画トリガー関数 ---
            function updatePreview() {
                const axiom = document.getElementById('axiom-input').value;
                state.rules = getCurrentRules();
                // ⭐️ 修正: 2世代分生成 (Depth 2)
                const lSystemStrings = generateLSystemWithDepth(axiom, state.rules, 2); 
                drawLSystem(previewCtx, lSystemStrings, false);
            }
            
            document.getElementById('color-by-depth').addEventListener('change', regenerateAndDraw);
            document.getElementById('keep-drawing').addEventListener('change', regenerateAndDraw);

            // 線の太さのラジオボタンの処理
            document.querySelectorAll('input[name="lineWidth"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    state.lineWidthOption = e.target.value;
                    saveHistory();
                    regenerateAndDraw();
                });
            });


            // --- 初期実行 ---
            
            // D&Dロジックの再設定 (パレットからのコピー)
            document.querySelectorAll('#palette-cards .card').forEach(card => {
                card.setAttribute('draggable', true);
                card.addEventListener('dragstart', (e) => {
                    draggedElement = createCardContainer(e.target.dataset.command, e.target.dataset.angle);
                    isMoving = false; 
                    e.dataTransfer.effectAllowed = 'copy';
                });
                card.addEventListener('dragend', () => {
                    if (!isMoving) { 
                        saveHistory();
                        updatePreview();
                        regenerateAndDraw(); 
                    }
                    draggedElement = null;
                    isMoving = false;
                    document.querySelectorAll('.drop-indicator').forEach(i => i.remove());
                });
            });
            

            resizeCanvas(); 
            zoomValueSpan.textContent = state.zoom.toFixed(1);
            maxDepthLimitSpan.textContent = MAX_DEPTH_HARD_LIMIT;
            
            // プリセット適用 -> 履歴保存 -> 初回描画実行
            applyPreset('koch-curve'); 
        });
    </script>
</body>
</html>