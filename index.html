<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>カード型 L-システムジェネレータ</title>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 10px; 
            background-color: #1e1e1e; 
            color: #d4d4d4; 
        }
        #app-container {
            display: flex;
            flex-direction: column; 
            max-width: 1600px; 
            margin: 0 auto;
            gap: 15px; 
            background-color: #252526; 
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
        }
        
        #main-content {
            display: flex;
            gap: 15px;
            flex-grow: 1;
        }

        #rule-editor-container {
            width: 380px; 
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-shrink: 0;
        }

        #controls-and-palette {
            width: 250px; 
            display: flex;
            flex-direction: column; 
            gap: 15px;
            flex-shrink: 0;
        }

        #drawing-area-container {
            flex-grow: 1; 
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        #rule-editor, #parameters, #palette {
            padding: 12px; 
            border-radius: 6px;
            background-color: #3c3c3c; 
        }
        
        #parameters {
            flex-grow: 1;
            overflow-y: auto; 
            max-height: 100%; 
        }

        #palette h2 {
            font-size: 1.1em;
            border-bottom: none;
            margin-bottom: 8px;
        }
        #palette-cards {
            display: flex; 
            flex-wrap: wrap; 
            gap: 8px; 
        }

        #preview-area {
            padding: 8px; 
            border-radius: 6px;
            background-color: #3c3c3c;
            height: 250px; 
            margin-top: 15px; 
            flex-shrink: 0;
        }
        #preview-canvas {
            display: block;
            margin-top: 5px;
            border: 1px dashed #5a5a5a;
            width: 100%;
            height: 200px; 
            background-color: black; 
        }


        #main-canvas-wrapper {
            position: relative;
            width: 100%;
            padding-bottom: 75%; 
            height: 0;
            overflow: hidden;
            border: 1px solid #5a5a5a;
            border-radius: 4px;
            flex-grow: 1;
        }
        #main-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black; 
            cursor: grab; 
        }
        #main-canvas:active {
            cursor: grabbing;
        }
        
        .rule-set {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .rule-set .arrow {
            font-size: 1.5em;
            margin: 0 5px; 
        }
        .rhs-rail {
            display: flex;
            gap: 3px; 
            flex-grow: 1;
            padding: 3px; 
            border: 1px dashed #5a5a5a;
            border-radius: 4px;
            min-height: 50px; 
            align-items: center;
            flex-wrap: wrap; 
            position: relative; 
        }
        .rhs-card-container {
            display: flex; 
            flex-direction: column;
            align-items: center;
            gap: 2px; 
            position: relative; 
            cursor: default; 
            flex-shrink: 0;
        }
        .rhs-card-container input.card-property {
            width: 35px; 
            font-size: 0.6em; 
            padding: 0px 2px;
            text-align: center;
            border: 1px solid #4a4a4a;
            background-color: #2e2e2e;
            color: #d4d4d4;
            border-radius: 3px;
        }

        .insertion-marker {
            position: absolute;
            width: 2px;
            background-color: #00bcd4; 
            opacity: 0.8;
            pointer-events: none; 
            display: none; 
            z-index: 10;
            height: 100%; 
        }

        .card, .lhs-card {
            display: inline-flex;
            flex-shrink: 0; 
            width: 40px; 
            height: 40px; 
            cursor: grab;
            border-radius: 6px; 
            font-weight: bold;
            font-size: 0.7em; 
            text-align: center;
            user-select: none;
            color: transparent; 
            background-size: 70%; 
            background-position: center;
            background-repeat: no-repeat;
            padding: 3px; 
            background-color: #3c3c3c; 
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
        }
        /* レール上のカードはドラッグ不可を明示 */
        .rhs-card-container .card {
            cursor: default !important; 
        }
        
        .color-green { border: 2px solid #4caf50; } 
        .color-cyan { border: 2px solid #00bcd4; } 
        .color-magenta { border: 2px solid #e91e63; } 
        
        /* コマンドアイコン画像は省略 (assets/command-x.png などの画像が必要です) */
        .card[data-command="F"], .lhs-card[data-command="F"] { background-image: url('command-f-draw.png'); }
        .card[data-command="f"] { background-image: url('command-f-move.png'); }
        .card[data-command="+"] { background-image: url('command-plus-right.png'); }
        .card[data-command="-"] { background-image: url('command-minus-left.png'); }
        .card[data-command="["], .lhs-card[data-command="["] { background-image: url('command-bracket-push.png'); }
        .card[data-command="]"] { background-image: url('command-bracket-pop.png'); }
        .card[data-command="X"], .lhs-card[data-command="X"] { background-image: url('command-x-variable.png'); }
        .card[data-command="Y"], .lhs-card[data-command="Y"] { background-image: url('command-y-variable.png'); }
        
        #depth-controls { display: flex; align-items: center; gap: 5px; margin-top: 5px; margin-bottom: 10px; }
        #generate-reset-buttons { display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px; } 
        .control-group { margin-top: 10px; padding-top: 10px; border-top: 1px solid #5a5a5a; }
        .zoom-controls { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }

        .perf-limit-group { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #5a5a5a; }
        .perf-limit-group input { width: 60px; }
        .perf-limit-group small { display: block; margin-top: 5px; color: #888; font-size: 0.8em; }
        
        .depth-info-container {
            display: flex;
            flex-direction: column;
        }

        .perf-limit-group small {
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <div id="app-container">
        
        <div id="main-content">

            <div id="rule-editor-container">
                <div id="rule-editor">
                    <h2>生成規則設定</h2>
                    
                    <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 15px;">
                        <label for="preset-select">プリセット:</label>
                        <select id="preset-select">
                            <option value="koch-curve">コッホ曲線 (基本)</option>
                            <option value="koch-snowflake">コッホ雪片 (閉)</option>
                            <option value="sierpinski-arrowhead">シェルピンスキー・アローヘッド</option>
                            <option value="dragon">ドラゴン曲線</option>
                            <option value="koch-island">コッホ・アイランド (四角)</option>
                            <option value="bush">ブッシュ/灌木 (植物)</option>
                            <option value="h-tree">H-Tree (木構造)</option>
                            <option value="hilbert-curve">ヒルベルト曲線</option>
                            <option value="sierpinski-gasket">シェルピンスキー・ギャスケット</option>
                            <option value="square-koch">四角コッホ (基本)</option>
                            <option value="fractal-plant">フラクタル・プラント</option>
                            <option value="weed">雑草/密な灌木</option>
                            <option value="peano-gosper">ピーノ・ゴスパー曲線</option>
                            <option value="levy-c-curve">レヴィC曲線</option>
                            <option value="cabbage">キャベツ/丸い樹木</option>
                            <option value="bushy-plant">密なブッシュ</option>
                            <option value="pentaplexity">ペンタプレキシティ</option>
                            <option value="flake">フレーク (四角)</option>
                            <option value="stochastic-plant-1">樹木 (対称)</option>
                            <option value="koch-variation-1">コッホ曲線 (変種)</option>
                            <option value="crystal">クリスタル</option>
                            <option value="tree-1">樹木 (シンプル)</option>
                            <option value="tree-2">樹木 (詳細)</option>
                            <option value="maze">メイズ/迷路</option>
                            <option value="t-square">Tスクエア</option>
                            <option value="spiral">スパイラル</option>
                            <option value="ring">リング</option>
                            <option value="island-lake">アイランド/レイク</option>
                        </select>
                    </div>

                    <div id="editor-buttons"> 
                        <button id="undo-button" disabled>アンドゥ (Undo)</button>
                        <button id="redo-button" disabled>リドゥ (Redo)</button>
                        <button id="clear-all-button">全ルールクリア</button>
                        <button id="random-rule-button" style="background-color: #3f6e8c;">ランダムルール生成</button>
                    </div>
                    
                    <label for="axiom-input" style="display: block; margin-top: 10px;">初期値 (Axiom):</label>
                    <input type="text" id="axiom-input" value="F" style="width: 100px; margin-bottom: 10px;">

                    <div class="rule-set">
                        <div class="lhs-card color-green" data-command="F">F</div>
                        <div class="arrow">→</div>
                        <div class="rhs-rail" data-target="F" id="rhs-rail-f">
                            <div class="insertion-marker"></div> 
                        </div>
                    </div>

                    <div class="rule-set">
                        <div class="lhs-card color-cyan" data-command="X">X</div>
                        <div class="arrow">→</div>
                        <div class="rhs-rail" data-target="X" id="rhs-rail-x">
                            <div class="insertion-marker"></div> 
                        </div>
                    </div>
                    
                    <div class="rule-set">
                        <div class="lhs-card color-cyan" data-command="Y">Y</div>
                        <div class="arrow">→</div>
                        <div class="rhs-rail" data-target="Y" id="rhs-rail-y">
                            <div class="insertion-marker"></div> 
                        </div>
                    </div>
                </div>

                <div id="preview-area">
                    <h3>2世代プレビュー (1世代目:白, 2世代目:緑)</h3>
                    <canvas id="preview-canvas"></canvas>
                </div>
            </div>
            
            <div id="controls-and-palette">
                
                <div id="palette">
                    <h2>コマンドパレット (Drag me!)</h2>
                    <div id="palette-cards">
                        <div class="card color-green" data-command="F" data-angle="60" draggable="true">F</div>
                        <div class="card color-green" data-command="+" data-angle="60" draggable="true">+</div>
                        <div class="card color-green" data-command="-" data-angle="60" draggable="true">-</div>
                        <div class="card color-magenta" data-command="f" data-angle="60" draggable="true">f</div>
                        <div class="card color-magenta" data-command="]" data-angle="60" draggable="true">]</div>
                        <div class="card color-cyan" data-command="[" data-angle="60" draggable="true">[</div>
                        <div class="card color-cyan" data-command="X" data-angle="60" draggable="true">X</div>
                        <div class="card color-cyan" data-command="Y" data-angle="60" draggable="true">Y</div>
                    </div>
                </div>

                <div id="parameters">
                    <h3>描画パラメータ</h3>
                    
                    <div class="perf-limit-group">
                        <h3>描画速度制限</h3>
                        <label for="target-draw-time">最大描画時間 (ms):</label>
                        <input type="number" id="target-draw-time" value="500" min="100" step="10">
                        <small>前回の描画時間: <span id="last-draw-time">0</span> ms</small>
                        <small>制限深度: **(最大 <span id="limited-depth-info">適用なし</span>)**</small>
                    </div>

                    <label for="depth">世代 (Depth): **(上限<span id="max-depth-limit">99</span>)**</label>
                    <div id="depth-controls">
                        <button id="depth-down">▼</button>
                        <span id="depth-value">0</span>
                        <button id="depth-up">▲</button>
                    </div>
                    
                    <div class="control-group">
                        <h3>線の太さ設定</h3>
                        <div id="line-width-options" style="display: flex; gap: 15px; margin-top: 5px;">
                            <label><input type="radio" name="lineWidth" value="fine"> 細 (1.5)</label>
                            <label><input type="radio" name="lineWidth" value="medium" checked> 中 (4.0)</label>
                            <label><input type="radio" name="lineWidth" value="bold"> 太 (8.0)</label>
                        </div>
                        
                        <div style="margin-top: 15px;">
                            <label for="thinning-rate-slider">深度による細線化率 (<span id="thinning-rate-value">0.8</span>):</label>
                            <input type="range" id="thinning-rate-slider" min="0.5" max="1.0" value="0.8" step="0.05" style="width: 100%;">
                        </div>
                        <div style="margin-top: 10px;">
                            <input type="checkbox" id="base-emphasis-glow" checked>
                            <label for="base-emphasis-glow">根元強調 (極太グロー)</label>
                        </div>
                    </div>

                    <label for="angle">グローバル回転角 ($\delta$):</label>
                    <input type="range" id="angle-slider" min="1" max="180" value="60" step="0.1" style="width: 100%;">
                    <input type="number" id="angle-input" min="1" max="180" value="60" step="0.1" style="width: 80px;">
                    <button id="sync-angle-button">全カードに適用</button>
                    
                    <div class="control-group">
                        <h3>表示オプション</h3>
                        <div class="depth-color-option" style="margin-top: 10px;">
                            <input type="checkbox" id="color-by-depth" checked>
                            <label for="color-by-depth">世代ごとに色分け</label>
                        </div>
                        <div class="depth-color-option">
                            <input type="checkbox" id="keep-drawing">
                            <label for="keep-drawing">前の世代を残像表示</label>
                        </div>
                        <div class="depth-color-option">
                            <input type="checkbox" id="fill-enclosed-areas">
                            <label for="fill-enclosed-areas">閉じた領域を塗りつぶし</label>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h3>ズーム &amp; パン</h3>
                        <label for="zoom-slider">ズーム倍率 (<span id="zoom-value">1.0</span>x):</label>
                        <div class="zoom-controls">
                            <input type="range" id="zoom-slider" min="0.1" max="10" value="1" step="0.1" style="flex-grow: 1;">
                            <button id="zoom-reset-button">リセット</button>
                        </div>
                        <div style="font-size: 0.8em; margin-top: 5px;">
                            (ホイールでズーム、ドラッグで移動)
                            <button id="pan-reset-button" style="padding: 2px 8px;">中央に戻す</button>
                        </div>
                    </div>

                    <div id="generate-reset-buttons">
                        <button id="reset-drawing-button" style="background-color: #5a5a5a;">描画リセット</button>
                    </div>
                </div>
            </div>

            <div id="drawing-area-container">
                <div id="drawing-area">
                    <h2>メイン描画 (世代: <span id="main-depth-display">0</span>)</h2>
                    <div id="main-canvas-wrapper">
                        <canvas id="main-canvas"></canvas>
                    </div>
                </div>
                </div>
        </div>
    </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {

    const HISTORY_LIMIT = 20;
    const MAX_DEPTH_HARD_LIMIT = 99; 
    const history = [];
    let historyIndex = -1;
    let cardIdCounter = 0; 

    const state = {
        depth: 0, 
        globalAngle: 60, 
        rules: { 'X': '', 'F': '', 'Y': '' },
        angleCommands: ['+', '-'],
        zoom: 1.0,           
        panX: 0,             
        panY: 0,
        lineWidthOption: 'medium', 
        thinningRate: 0.8, 
        baseEmphasisGlow: true, 
        fillEnclosed: false, 
        targetDrawTime: 500, 
        limitedDepth: MAX_DEPTH_HARD_LIMIT,
        autoScale: 1.0, 
        autoPanX: 0, 
        autoPanY: 0
    };

    let isDraggingCanvas = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    const mainCanvas = document.getElementById('main-canvas');
    const previewCanvas = document.getElementById('preview-canvas');
    
    // 描画コンテキストの定義
    const mainCtx = mainCanvas ? mainCanvas.getContext('2d') : null;
    const previewCtx = previewCanvas ? previewCanvas.getContext('2d') : null;

    const undoButton = document.getElementById('undo-button');
    const redoButton = document.getElementById('redo-button');
    const paletteContainer = document.getElementById('palette'); 

    const presetSelect = document.getElementById('preset-select'); 
    const axiomInput = document.getElementById('axiom-input');
    
    const depthValueSpan = document.getElementById('depth-value');
    const mainDepthDisplay = document.getElementById('main-depth-display');
    const angleSlider = document.getElementById('angle-slider');
    const angleInput = document.getElementById('angle-input');
    const rhsRails = Array.from(document.querySelectorAll('.rhs-rail'));
    const maxDepthLimitSpan = document.getElementById('max-depth-limit');
    const lastDrawTimeSpan = document.getElementById('last-draw-time');
    const limitedDepthInfoSpan = document.getElementById('limited-depth-info');
    const targetDrawTimeInput = document.getElementById('target-draw-time');

    const zoomSlider = document.getElementById('zoom-slider');
    const zoomValueSpan = document.getElementById('zoom-value');

    const thinningRateSlider = document.getElementById('thinning-rate-slider');
    const thinningRateValueSpan = document.getElementById('thinning-rate-value');
    const baseEmphasisGlowCheckbox = document.getElementById('base-emphasis-glow');
    const fillEnclosedCheckbox = document.getElementById('fill-enclosed-areas');
    const syncAngleButton = document.getElementById('sync-angle-button');
    const clearAllButton = document.getElementById('clear-all-button');
    const randomRuleButton = document.getElementById('random-rule-button');
    const resetDrawingButton = document.getElementById('reset-drawing-button');
    const keepDrawingCheckbox = document.getElementById('keep-drawing');
    const colorByDepthCheckbox = document.getElementById('color-by-depth');

    // 角度を含むコマンドをパースするための正規表現
    const ANGLE_REGEX = /^([+\-])\((\d+(\.\d+)?)\)/;

    // ===========================================
    // DOM操作ユーティリティ
    // ===========================================

    function createCardContainer(command, angle) {
        const container = document.createElement('div');
        container.className = 'rhs-card-container';
        container.dataset.command = command;
        container.dataset.cardId = cardIdCounter++;
        
        const card = document.createElement('div');
        card.className = `card ${getColorClass(command)}`;
        card.dataset.command = command;
        card.textContent = command; 
        
        let angleInputEl = null;
        
        // アングルコマンド（+ または -）の場合のみ角度入力を作成
        if (state.angleCommands.includes(command)) {
            angleInputEl = document.createElement('input');
            angleInputEl.type = 'number';
            angleInputEl.className = 'card-property angle-input';
            angleInputEl.value = angle.toFixed(1);
            angleInputEl.min = 1;
            angleInputEl.max = 180;
            angleInputEl.step = 0.1;
            angleInputEl.addEventListener('input', () => {
                regenerateAndDraw();
                updatePreview();
            });
            angleInputEl.addEventListener('change', saveHistory);
            
            container.appendChild(angleInputEl);
        }
        
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'x';
        deleteButton.className = 'delete-card-button';
        deleteButton.style.cssText = 'position: absolute; top: -10px; right: -10px; width: 18px; height: 18px; border-radius: 50%; border: none; background: #e91e63; color: white; font-size: 0.7em; cursor: pointer; z-index: 5; line-height: 1; padding: 0; display: none;';
        
        container.appendChild(card);
        container.appendChild(deleteButton);

        container.addEventListener('mouseenter', () => deleteButton.style.display = 'block');
        container.addEventListener('mouseleave', () => deleteButton.style.display = 'none');
        
        deleteButton.addEventListener('click', (e) => {
            e.stopPropagation();
            container.remove();
            regenerateAndDraw();
            updatePreview();
            saveHistory();
        });
        
        return container;
    }

    function getColorClass(command) {
        if (['F', '+', '-'].includes(command)) return 'color-green';
        if (['X', 'Y', '['].includes(command)) return 'color-cyan';
        if (['f', ']'].includes(command)) return 'color-magenta';
        return '';
    }

    function getCurrentRules() {
        const rules = { 'X': '', 'F': '', 'Y': '' };
        
        rhsRails.forEach(rail => {
            const target = rail.dataset.target;
            let ruleString = '';
            
            Array.from(rail.querySelectorAll('.rhs-card-container')).forEach(container => {
                const command = container.dataset.command;
                let part = command;
                
                if (state.angleCommands.includes(command)) {
                    // 角度入力要素を探す
                    const angleInput = container.querySelector('.angle-input');
                    if (angleInput) { // 要素が存在する場合のみ角度を取得
                        const angle = parseFloat(angleInput.value).toFixed(1);
                        part += `(${angle})`; 
                    }
                }
                ruleString += part;
            });
            
            rules[target] = ruleString;
        });
        
        return rules;
    }

    function applyRulesToRail(railElement, ruleString, globalAngle) {
        // 既存の要素をクリアし、挿入マーカーを再配置
        railElement.innerHTML = '<div class="insertion-marker"></div>';
        
        let i = 0;
        while (i < ruleString.length) {
            let command = ruleString[i];
            let cardAngle = globalAngle;
            let step = 1;
            
            // 角度付きコマンドをチェック
            if (state.angleCommands.includes(command)) {
                const angleMatch = ruleString.substring(i).match(ANGLE_REGEX);
                if (angleMatch) {
                    command = angleMatch[1]; // コマンド自体は + または -
                    cardAngle = parseFloat(angleMatch[2]); // 括弧内の角度
                    step = angleMatch[0].length; // コマンドと角度全体をスキップするためのステップ
                }
            }
            
            // 有効なL-システムコマンドのみカードを作成
            if (['F', 'f', '+', '-', '[', ']', 'X', 'Y'].includes(command)) {
                const cardContainer = createCardContainer(command, cardAngle);
                // 挿入マーカーの直前にカードを挿入（常に末尾に追加）
                const insertionMarker = railElement.querySelector('.insertion-marker');
                railElement.insertBefore(cardContainer, insertionMarker);
            }
            
            i += step;
        }
    }


    function resizeCanvas() {
        const mainWrapper = document.getElementById('main-canvas-wrapper');
        const prevWrapper = document.getElementById('preview-area');
        
        if (!mainWrapper || !prevWrapper || !mainCanvas || !previewCanvas) return; 

        mainCanvas.width = mainWrapper.clientWidth;
        mainCanvas.height = mainWrapper.clientHeight; 
        
        previewCanvas.width = prevWrapper.clientWidth - 16; 
        previewCanvas.height = 200; 
        
        if (history.length > 0 || state.depth >= 0) { 
            regenerateAndDraw(); 
        } else {
            updatePreview();
        }
    }
    window.addEventListener('resize', resizeCanvas);


    // ===========================================
    // 履歴管理
    // ===========================================
    
    function updateHistoryButtons() {
        undoButton.disabled = historyIndex <= 0;
        redoButton.disabled = historyIndex >= history.length - 1;
    }

    function updateDepthButtonsState() {
        const depthUpButton = document.getElementById('depth-up');
        const depthDownButton = document.getElementById('depth-down');

        if (depthUpButton && depthDownButton) {
            depthUpButton.disabled = state.depth >= state.limitedDepth;
            depthDownButton.disabled = state.depth <= 0;
        }
    }


    function getCurrentStateForHistory() {
        return {
            depth: state.depth,
            globalAngle: state.globalAngle,
            axiom: document.getElementById('axiom-input').value,
            rules: getCurrentRules(),
            zoom: state.zoom,
            panX: state.panX,
            panY: state.panY,
            lineWidthOption: state.lineWidthOption,
            thinningRate: state.thinningRate, 
            baseEmphasisGlow: state.baseEmphasisGlow, 
            fillEnclosed: state.fillEnclosed, 
            targetDrawTime: state.targetDrawTime,
            keepDrawing: keepDrawingCheckbox.checked,
            colorByDepth: colorByDepthCheckbox.checked
        };
    }

    function loadStateFromHistory(savedState) {
        state.depth = savedState.depth;
        state.globalAngle = savedState.globalAngle;
        state.zoom = savedState.zoom;
        state.panX = savedState.panX;
        state.panY = savedState.panY;
        state.lineWidthOption = savedState.lineWidthOption || 'medium'; 
        state.thinningRate = savedState.thinningRate === undefined ? 0.8 : savedState.thinningRate;
        state.baseEmphasisGlow = savedState.baseEmphasisGlow === undefined ? true : savedState.baseEmphasisGlow; 
        state.fillEnclosed = savedState.fillEnclosed === undefined ? false : savedState.fillEnclosed; 
        state.targetDrawTime = savedState.targetDrawTime === undefined ? 500 : savedState.targetDrawTime;
        
        document.getElementById('axiom-input').value = savedState.axiom;
        updateAngle(savedState.globalAngle, false); 
        targetDrawTimeInput.value = state.targetDrawTime; 
        updateZoom(savedState.zoom, false); 
        updateDepth(savedState.depth, false); 

        const lineWidthRadio = document.querySelector(`input[name="lineWidth"][value="${state.lineWidthOption}"]`);
        if(lineWidthRadio) lineWidthRadio.checked = true;

        thinningRateSlider.value = state.thinningRate;
        thinningRateValueSpan.textContent = state.thinningRate.toFixed(2);
        baseEmphasisGlowCheckbox.checked = state.baseEmphasisGlow;
        fillEnclosedCheckbox.checked = savedState.fillEnclosed; 
        keepDrawingCheckbox.checked = savedState.keepDrawing === undefined ? false : savedState.keepDrawing;
        colorByDepthCheckbox.checked = savedState.colorByDepth === undefined ? true : savedState.colorByDepth;

        const railF = document.getElementById('rhs-rail-f');
        const railX = document.getElementById('rhs-rail-x');
        const railY = document.getElementById('rhs-rail-y'); 
        
        if (railF) applyRulesToRail(railF, savedState.rules.F || '', savedState.globalAngle);
        if (railX) applyRulesToRail(railX, savedState.rules.X || '', savedState.globalAngle);
        if (railY) applyRulesToRail(railY, savedState.rules.Y || '', savedState.globalAngle);

        regenerateAndDraw();
        updatePreview();
        updateHistoryButtons();
        updateDepthButtonsState();
    }

    function saveHistory() {
        if (historyIndex < history.length - 1) {
            history.splice(historyIndex + 1);
        }
        
        const currentState = getCurrentStateForHistory();

        if (history.length === 0 || JSON.stringify(history[history.length - 1]) !== JSON.stringify(currentState)) {
            history.push(currentState);
            historyIndex = history.length - 1;

            if (history.length > HISTORY_LIMIT) {
                history.shift();
                historyIndex--;
            }
        }
        
        updateHistoryButtons();
    }
    
    undoButton.addEventListener('click', () => {
        if (historyIndex > 0) {
            historyIndex--;
            loadStateFromHistory(history[historyIndex]);
        }
    });
    
    redoButton.addEventListener('click', () => {
        if (historyIndex < history.length - 1) {
            historyIndex++;
            loadStateFromHistory(history[historyIndex]);
        }
    });

    // ===========================================
    // L-システムコアロジック
    // ===========================================

    function generateLSystemWithDepth(axiom, rules, iterations) {
        const strings = [axiom];
        let currentString = axiom;
        
        for (let depth = 1; depth <= iterations; depth++) {
            let nextString = '';
            for (let i = 0; i < currentString.length; i++) {
                const char = currentString[i];
                
                if (state.angleCommands.includes(char)) {
                    const angleMatch = currentString.substring(i).match(ANGLE_REGEX);
                    if (angleMatch) {
                        nextString += angleMatch[0]; 
                        i += angleMatch[0].length - 1; 
                        continue;
                    }
                }

                if (rules[char] !== undefined) {
                    nextString += rules[char];
                } else {
                    nextString += char;
                }
            }
            currentString = nextString;
            strings.push(currentString);
        }
        return strings;
    }

    // ===========================================
    // 描画ロジックのユーティリティ
    // ===========================================

    function getLSystemBounds(lSystemString, globalAngle) {
        let x = 0;
        let y = 0;
        let minX = 0;
        let minY = 0;
        let maxX = 0;
        let maxY = 0;
        let currentAngle = -90; 
        const stack = [];
        const baseLineLength = 1.0; 

        for (let i = 0; i < lSystemString.length; i++) {
            const command = lSystemString[i];
            let turnAngle = globalAngle;

            if (state.angleCommands.includes(command)) {
                const angleMatch = lSystemString.substring(i).match(ANGLE_REGEX);
                if (angleMatch) {
                    turnAngle = parseFloat(angleMatch[2]);
                    i += angleMatch[0].length - 1; 
                }
            }
            
            switch (command) {
                case 'F':
                case 'f':
                    const dx = baseLineLength * Math.cos(currentAngle * Math.PI / 180);
                    const dy = baseLineLength * Math.sin(currentAngle * Math.PI / 180);
                    x += dx;
                    y += dy;
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                    break;
                case '+': currentAngle += turnAngle; break;
                case '-': currentAngle -= turnAngle; break;
                case '[':
                    stack.push({ x, y, angle: currentAngle });
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                    break;
                case ']':
                    const stateRestored = stack.pop();
                    if (stateRestored) {
                        x = stateRestored.x;
                        y = stateRestored.y;
                        currentAngle = stateRestored.angle;
                    }
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                    break;
            }
        }

        return {
            minX,
            minY,
            maxX,
            maxY,
            width: maxX - minX,
            height: maxY - minY
        };
    }

    function getBaseLineWidth() {
        switch (state.lineWidthOption) {
            case 'fine': return 1.5; 
            case 'medium': return 4.0;
            case 'bold': return 8.0;
            default: return 4.0;
        }
    }

    // ===========================================
    // UIコントロールと描画トリガー
    // ===========================================

    function updateAngle(newAngle, shouldSaveHistory = true) {
        state.globalAngle = parseFloat(newAngle);
        angleSlider.value = state.globalAngle;
        angleInput.value = state.globalAngle;
        regenerateAndDraw();
        updatePreview();
        if (shouldSaveHistory) saveHistory();
    }
    
    angleSlider.addEventListener('input', (e) => updateAngle(e.target.value, false));
    angleSlider.addEventListener('change', () => saveHistory());
    angleInput.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        if (!isNaN(value)) {
            updateAngle(value, false);
        }
    });
    angleInput.addEventListener('change', () => saveHistory());

    syncAngleButton.addEventListener('click', () => {
        const globalAngle = state.globalAngle;
        rhsRails.forEach(rail => {
            Array.from(rail.querySelectorAll('.angle-input')).forEach(input => {
                input.value = globalAngle.toFixed(1);
            });
        });
        regenerateAndDraw();
        updatePreview();
        saveHistory();
    });
    
    document.querySelectorAll('input[name="lineWidth"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            state.lineWidthOption = e.target.value;
            regenerateAndDraw();
            saveHistory();
        });
    });
    
    thinningRateSlider.addEventListener('input', (e) => {
        state.thinningRate = parseFloat(e.target.value);
        thinningRateValueSpan.textContent = state.thinningRate.toFixed(2);
        regenerateAndDraw();
    });
    thinningRateSlider.addEventListener('change', () => saveHistory());

    baseEmphasisGlowCheckbox.addEventListener('change', (e) => {
        state.baseEmphasisGlow = e.target.checked;
        saveHistory();
        regenerateAndDraw();
    });
    
    fillEnclosedCheckbox.addEventListener('change', (e) => {
        state.fillEnclosed = e.target.checked;
        saveHistory();
        regenerateAndDraw();
    });

    keepDrawingCheckbox.addEventListener('change', () => {
        saveHistory();
        regenerateAndDraw();
    });

    colorByDepthCheckbox.addEventListener('change', () => {
        saveHistory();
        regenerateAndDraw();
    });

    function updateZoom(newZoom, shouldSaveHistory = true) {
        state.zoom = newZoom;
        zoomSlider.value = newZoom;
        zoomValueSpan.textContent = newZoom.toFixed(1);
        regenerateAndDraw();
        if (shouldSaveHistory) saveHistory();
    }

    zoomSlider.addEventListener('input', (e) => {
        updateZoom(parseFloat(e.target.value), false);
    });
    zoomSlider.addEventListener('change', () => saveHistory());

    document.getElementById('zoom-reset-button').addEventListener('click', () => {
        updateZoom(1.0);
    });
    document.getElementById('pan-reset-button').addEventListener('click', () => {
        state.panX = 0;
        state.panY = 0;
        regenerateAndDraw();
        saveHistory();
    });


    mainCanvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const scaleFactor = 1.1;
        const oldZoom = state.zoom;
        let newZoom = oldZoom;

        if (e.deltaY < 0) {
            newZoom = Math.min(10, oldZoom * scaleFactor); 
        } else {
            newZoom = Math.max(0.1, oldZoom / scaleFactor); 
        }

        const rect = mainCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const finalScaleFactor = newZoom / oldZoom; 
        
        const oldPanX = state.panX;
        const oldPanY = state.panY;

        state.panX = mouseX * (1 - finalScaleFactor) + oldPanX * finalScaleFactor;
        state.panY = mouseY * (1 - finalScaleFactor) + oldPanY * finalScaleFactor;

        state.zoom = newZoom;
        zoomSlider.value = newZoom;
        zoomValueSpan.textContent = newZoom.toFixed(1);

        regenerateAndDraw();
        saveHistory();
    });

    mainCanvas.addEventListener('mousedown', (e) => {
        isDraggingCanvas = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        mainCanvas.style.cursor = 'grabbing';
    });

    window.addEventListener('mouseup', () => {
        if (isDraggingCanvas) {
            isDraggingCanvas = false;
            mainCanvas.style.cursor = 'grab';
            saveHistory();
        }
    });

    window.addEventListener('mousemove', (e) => {
        if (!isDraggingCanvas) return;
        
        const dx = e.clientX - lastMouseX;
        const dy = e.clientY - lastMouseY;
        
        state.panX += dx;
        state.panY += dy;
        
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        
        regenerateAndDraw();
    });

    function updateDepth(newDepth, shouldSaveHistory = true) {
        state.depth = Math.max(0, Math.min(state.limitedDepth, newDepth));
        depthValueSpan.textContent = state.depth;
        mainDepthDisplay.textContent = state.depth;

        updateDepthButtonsState();
        
        if (shouldSaveHistory) {
            state.panX = 0;
            state.panY = 0;
            state.zoom = 1.0;
            updateZoom(1.0, false); 
            saveHistory();
        }
        
        regenerateAndDraw();
    }

    document.getElementById('depth-up').addEventListener('click', () => {
        updateDepth(state.depth + 1);
    });

    document.getElementById('depth-down').addEventListener('click', () => {
        updateDepth(state.depth - 1);
    });
    
    function checkAndLimitDepth(drawTime) {
        const threshold = state.targetDrawTime * 1.5; 
        
        if (drawTime > threshold) {
            state.limitedDepth = state.depth;
            document.getElementById('max-depth-limit').textContent = state.limitedDepth;
            limitedDepthInfoSpan.textContent = state.limitedDepth;
            updateDepthButtonsState();
        } else if (drawTime < state.targetDrawTime * 0.5 && state.limitedDepth !== MAX_DEPTH_HARD_LIMIT) {
            state.limitedDepth = MAX_DEPTH_HARD_LIMIT;
            document.getElementById('max-depth-limit').textContent = MAX_DEPTH_HARD_LIMIT;
            limitedDepthInfoSpan.textContent = '適用なし';
            updateDepthButtonsState();
        }
    }

    targetDrawTimeInput.addEventListener('change', (e) => {
        state.targetDrawTime = parseInt(e.target.value);
        saveHistory();
        regenerateAndDraw();
    });
    
    resetDrawingButton.addEventListener('click', () => {
        state.panX = 0;
        state.panY = 0;
        updateZoom(1.0);
        saveHistory();
    });


    function calculateAutoTransform(lSystemString, canvasWidth, canvasHeight) {
        const actualBounds = getLSystemBounds(lSystemString, state.globalAngle);

        const minSafeSize = 1.0;
        const safeWidth = Math.max(actualBounds.width, minSafeSize);
        const safeHeight = Math.max(actualBounds.height, minSafeSize);
        
        const targetRatio = 0.9;

        const targetWidth = canvasWidth * targetRatio;
        const targetHeight = canvasHeight * targetRatio;
        
        let autoScale = 1.0;

        if (safeWidth > 0 && safeHeight > 0) {
            autoScale = Math.min(targetWidth / safeWidth, targetHeight / safeHeight);
        }

        const autoPanX = canvasWidth / 2 - (actualBounds.width * autoScale) / 2 - actualBounds.minX * autoScale;
        const autoPanY = canvasHeight / 2 - (actualBounds.height * autoScale) / 2 - actualBounds.minY * autoScale;

        state.autoScale = autoScale;
        state.autoPanX = autoPanX;
        state.autoPanY = autoPanY;

        return { autoScale, autoPanX, autoPanY, bounds: actualBounds };
    }


    function regenerateAndDraw() {
        const startTime = performance.now();
        const axiom = document.getElementById('axiom-input').value;
        const iterations = state.depth;
        state.rules = getCurrentRules();
        mainDepthDisplay.textContent = iterations;

        const lSystemStrings = generateLSystemWithDepth(axiom, state.rules, iterations);

        if (mainCtx) {
            drawLSystem(mainCtx, lSystemStrings, true);
        }

        updatePreview(lSystemStrings);

        const endTime = performance.now();
        const drawTime = (endTime - startTime).toFixed(2);
        lastDrawTimeSpan.textContent = drawTime;
        checkAndLimitDepth(parseFloat(drawTime));
    }

    // ===========================================
    // 描画実装
    // ===========================================

    function performDrawing(ctx, lSystemStrings, isMainCanvas, finalZoom, finalPanX, finalPanY, autoScale, startBaseX, startBaseY) {
        const iterations = lSystemStrings.length - 1;
        const L_SYSTEM_LENGTH_RATIO = 3.0; 
        const manualZoom = state.zoom; 

        if (state.fillEnclosed) {
            runFillPass(ctx, lSystemStrings, iterations, finalZoom, finalPanX, finalPanY, startBaseX, startBaseY, colorByDepthCheckbox.checked, keepDrawingCheckbox.checked);
        }

        const startDepth = keepDrawingCheckbox.checked ? 0 : iterations;
        const endDepth = iterations;
        const baseLineWidth = getBaseLineWidth();

        for (let depth = startDepth; depth <= endDepth; depth++) {
            const lSystemString = lSystemStrings[depth];
            let x = startBaseX;
            let y = startBaseY;
            let currentAngle = -90; 
            const stack = [];
            
            const currentDisplacement = Math.pow(L_SYSTEM_LENGTH_RATIO, iterations - depth);

            let lineWidth = baseLineWidth * manualZoom * Math.pow(state.thinningRate, depth);

            if (state.baseEmphasisGlow && depth === 0) {
                lineWidth = baseLineWidth * manualZoom * 1.5; 
                ctx.shadowColor = '#00ffaa'; 
                ctx.shadowBlur = baseLineWidth * 2 * manualZoom; 
            } else {
                ctx.shadowBlur = 0;
            }

            if (colorByDepthCheckbox.checked) {
                const HUE_STEP = 30;
                const hue = (depth * HUE_STEP) % 360;
                let saturation = 70;
                let lightness = 65;
                if (!isMainCanvas) {
                    saturation = 100;
                    lightness = 50;
                    if (depth === 1) ctx.strokeStyle = 'white'; 
                    if (depth === 2) ctx.strokeStyle = 'lime';  
                    ctx.globalAlpha = 1.0;
                } else {
                    ctx.strokeStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    ctx.globalAlpha = (keepDrawingCheckbox.checked && depth < iterations) ? 0.3 : 1.0;
                }
            } else {
                ctx.strokeStyle = 'white';
                ctx.globalAlpha = (keepDrawingCheckbox.checked && depth < iterations) ? 0.3 : 1.0;
            }

            ctx.lineWidth = Math.max(0.5, lineWidth); 
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            ctx.moveTo(x * finalZoom + finalPanX, y * finalZoom + finalPanY);

            for (let i = 0; i < lSystemString.length; i++) {
                const command = lSystemString[i];
                let turnAngle = state.globalAngle;

                if (state.angleCommands.includes(command)) {
                    const angleMatch = lSystemString.substring(i).match(ANGLE_REGEX);
                    if (angleMatch) {
                        turnAngle = parseFloat(angleMatch[2]);
                        i += angleMatch[0].length - 1; 
                    }
                }

                switch (command) {
                    case 'F':
                        const dx_F = currentDisplacement * Math.cos(currentAngle * Math.PI / 180);
                        const dy_F = currentDisplacement * Math.sin(currentAngle * Math.PI / 180);
                        x += dx_F;
                        y += dy_F;
                        ctx.lineTo(x * finalZoom + finalPanX, y * finalZoom + finalPanY);
                        break;
                    case 'f':
                        const dx_f = currentDisplacement * Math.cos(currentAngle * Math.PI / 180);
                        const dy_f = currentDisplacement * Math.sin(currentAngle * Math.PI / 180);
                        x += dx_f;
                        y += dy_f;
                        ctx.moveTo(x * finalZoom + finalPanX, y * finalZoom + finalPanY);
                        break;
                    case '+': currentAngle += turnAngle; break;
                    case '-': currentAngle -= turnAngle; break;
                    case '[':
                        stack.push({ x, y, angle: currentAngle });
                        break;
                    case ']':
                        const stateRestored = stack.pop();
                        if (stateRestored) {
                            x = stateRestored.x;
                            y = stateRestored.y;
                            currentAngle = stateRestored.angle;
                        }
                        ctx.moveTo(x * finalZoom + finalPanX, y * finalZoom + finalPanY);
                        break;
                }
            }
            ctx.stroke();
        }
    }

    // ===========================================
    // 塗りつぶし専用ロジック
    // ===========================================

    function runFillPass(ctx, lSystemStrings, iterations, scale, panX, panY, startBaseX, startBaseY, colorByDepth, keepDrawing) {
        const startDepth = keepDrawing ? 0 : iterations;
        const endDepth = iterations;
        ctx.globalAlpha = 1.0; 
        const L_SYSTEM_LENGTH_RATIO = 3.0; 

        for (let depth = startDepth; depth <= endDepth; depth++) {
            const lSystemString = lSystemStrings[depth];
            let x = startBaseX;
            let y = startBaseY;
            let currentAngle = -90; 
            
            const currentDisplacement = Math.pow(L_SYSTEM_LENGTH_RATIO, iterations - depth);
            
            if (colorByDepth) {
                const HUE_STEP = 30;
                const hue = (depth * HUE_STEP) % 360;
                const minAlpha = 0.4;
                const maxAlpha = 0.6;
                const alpha = minAlpha + (maxAlpha - minAlpha) / iterations * depth;
                ctx.fillStyle = `hsla(${hue}, 60%, 35%, ${alpha})`;
            } else {
                ctx.fillStyle = 'rgba(100, 100, 100, 0.4)';
            }
            
            const fillStack = [];
            
            for (let i = 0; i < lSystemString.length; i++) {
                const command = lSystemString[i];
                let turnAngle = state.globalAngle;

                if (state.angleCommands.includes(command)) {
                    const angleMatch = lSystemString.substring(i).match(ANGLE_REGEX);
                    if (angleMatch) {
                        turnAngle = parseFloat(angleMatch[2]);
                        i += angleMatch[0].length - 1; 
                    }
                }

                switch (command) {
                    case 'F':
                        const dx_F = currentDisplacement * Math.cos(currentAngle * Math.PI / 180);
                        const dy_F = currentDisplacement * Math.sin(currentAngle * Math.PI / 180);
                        const newX_F = x + dx_F;
                        const newY_F = y + dy_F;
                        if (fillStack.length > 0) {
                            ctx.lineTo(newX_F * scale + panX, newY_F * scale + panY);
                        }
                        x = newX_F;
                        y = newY_F;
                        break;
                    case 'f':
                        const dx_f = currentDisplacement * Math.cos(currentAngle * Math.PI / 180);
                        const dy_f = currentDisplacement * Math.sin(currentAngle * Math.PI / 180);
                        x += dx_f;
                        y += dy_f;
                        if (fillStack.length > 0) {
                            ctx.moveTo(x * scale + panX, y * scale + panY);
                        }
                        break;
                    case '+': currentAngle += turnAngle; break;
                    case '-': currentAngle -= turnAngle; break;
                    case '[':
                        fillStack.push({ x, y, angle: currentAngle });
                        ctx.beginPath();
                        ctx.moveTo(x * scale + panX, y * scale + panY);
                        break;
                    case ']':
                        const fillState = fillStack.pop();
                        if (fillState) {
                            ctx.closePath();
                            ctx.fill();
                            x = fillState.x;
                            y = fillState.y;
                            currentAngle = fillState.angle;
                        }
                        ctx.moveTo(x * scale + panX, y * scale + panY);
                        break;
                }
            }
        }
    }


    function drawLSystem(ctx, lSystemStrings, isMainCanvas) {
        const iterations = lSystemStrings.length - 1;
        const lSystemString = lSystemStrings[iterations];
        const canvas = isMainCanvas ? mainCanvas : previewCanvas;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (iterations < 0) return;

        let startBaseX = 0;
        let startBaseY = 0;
        let finalZoom;
        let finalPanX;
        let finalPanY;
        let autoScale; 

        if (isMainCanvas) {
            const autoTransform = calculateAutoTransform(lSystemString, mainCanvas.width, mainCanvas.height);
            autoScale = autoTransform.autoScale; 
            finalZoom = autoScale * state.zoom;
            finalPanX = autoTransform.autoPanX + state.panX;
            finalPanY = autoTransform.autoPanY + state.panY;

        } else {
            const previewStringForBounds = lSystemStrings[Math.min(2, lSystemStrings.length - 1)]; 
            const previewBounds = getLSystemBounds(previewStringForBounds, state.globalAngle); 
            const targetRatio = 0.9;
            const targetWidth = previewCanvas.width * targetRatio;
            const targetHeight = previewCanvas.height * targetRatio;

            let previewScale = 1.0;
            if (previewBounds.width > 0 && previewBounds.height > 0) {
                previewScale = Math.min(targetWidth / previewBounds.width, targetHeight / previewBounds.height);
            } else {
                previewScale = Math.min(previewCanvas.width, previewCanvas.height) * 0.5;
            }

            autoScale = previewScale; 
            finalZoom = previewScale;
            finalPanX = previewCanvas.width / 2 - (previewBounds.width * previewScale) / 2 - previewBounds.minX * previewScale;
            finalPanY = previewCanvas.height / 2 - (previewBounds.height * previewScale) / 2 - previewBounds.minY * previewScale;
            
            lSystemStrings = lSystemStrings.slice(0, Math.min(lSystemStrings.length, 3));
        }
        
        performDrawing(ctx, lSystemStrings, isMainCanvas, finalZoom, finalPanX, finalPanY, autoScale, startBaseX, startBaseY);
    }

    function updatePreview(lSystemStrings = null) {
        if (!previewCtx) return; 

        if (!lSystemStrings) {
            const axiom = document.getElementById('axiom-input').value;
            state.rules = getCurrentRules();
            lSystemStrings = generateLSystemWithDepth(axiom, state.rules, 2); 
        }
        drawLSystem(previewCtx, lSystemStrings, false);
    }
    
    // ===========================================
    // プリセットとドラッグ＆ドロップ
    // ===========================================
    
    const PRESETS = {
        'koch-curve': {
            axiom: 'F',
            globalAngle: 60.0,
            rules: { 'X': '', 'F': 'F+(60)F-(120)F+(60)F', 'Y': '' }
        },
        'koch-snowflake': {
            axiom: 'F++F++F',
            globalAngle: 60.0,
            rules: { 'X': '', 'F': 'F+(60)F-(120)F+(60)F', 'Y': '' }
        },
        'ring': { 
            axiom: 'X',
            globalAngle: 60.0,
            rules: { 'X': 'FX', 'F': 'F++F++F', 'Y': '' } 
        },
        'sierpinski-arrowhead': {
            axiom: 'F',
            globalAngle: 60.0,
            rules: { 'F': 'X+(60)F+(60)X', 'X': 'F-(60)X-(60)F', 'Y': '' }
        },
        'dragon': { // 修正: 標準的なドラゴン曲線
            axiom: 'FX', 
            globalAngle: 90.0,
            rules: { 'X': 'X+(90)YF', 'F': 'F', 'Y': 'FX-(90)Y' } 
        },
        'koch-island': {
            axiom: 'F+F+F+F',
            globalAngle: 90.0,
            rules: { 'X': '', 'F': 'F+F-F-F+F', 'Y': '' }
        },
        'bush': {
            axiom: 'F',
            globalAngle: 25.0,
            rules: { 'X': '', 'F': 'FF-[-(25)+F+F]+[+(25)+F-F]', 'Y': '' }
        },
        'h-tree': {
            axiom: 'F',
            globalAngle: 90.0,
            rules: { 'X': '', 'F': 'F[+(90)F][-(90)F]', 'Y': '' } 
        }
        // sierpinski-gasket は一旦削除しました
    };
    
    function loadPreset(presetName) {
        const preset = PRESETS[presetName];
        if (!preset) return;
        
        saveHistory(); 
        
        document.getElementById('axiom-input').value = preset.axiom;
        updateAngle(preset.globalAngle, false); 
        
        const railF = document.getElementById('rhs-rail-f');
        const railX = document.getElementById('rhs-rail-x');
        const railY = document.getElementById('rhs-rail-y'); 

        // applyRulesToRail を使ってカードを生成し、レールに配置
        // プリセット読み込み時に、ルールが空の場合は空文字列 ('') を渡すことで、レールをクリアする
        if (railF) applyRulesToRail(railF, preset.rules.F || '', preset.globalAngle);
        if (railX) applyRulesToRail(railX, preset.rules.X || '', preset.globalAngle);
        if (railY) applyRulesToRail(railY, preset.rules.Y || '', preset.globalAngle);
        
        updateDepth(0, false); 
        state.panX = 0;
        state.panY = 0;
        state.zoom = 1.0;
        updateZoom(1.0, false); 
        
        saveHistory();
    }
    
    if (presetSelect) { 
        presetSelect.addEventListener('change', (e) => {
            loadPreset(e.target.value);
        });
    }

    axiomInput.addEventListener('input', () => {
        updatePreview();
    });
    axiomInput.addEventListener('change', () => {
        saveHistory();
        regenerateAndDraw();
    });
    
    clearAllButton.addEventListener('click', () => {
        saveHistory();
        document.getElementById('axiom-input').value = '';
        document.getElementById('rhs-rail-f').innerHTML = '<div class="insertion-marker"></div>';
        document.getElementById('rhs-rail-x').innerHTML = '<div class="insertion-marker"></div>';
        document.getElementById('rhs-rail-y').innerHTML = '<div class="insertion-marker"></div>';
        regenerateAndDraw();
        updatePreview();
        saveHistory();
    });

    randomRuleButton.addEventListener('click', () => {
        alert('ランダムルール生成機能は未実装です。');
    });

    // ===========================================
    // ドラッグ＆ドロップロジック
    // ===========================================
    
    paletteContainer.querySelectorAll('.card').forEach(card => {
        card.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', e.target.dataset.command);
            e.dataTransfer.effectAllowed = 'copy';
            e.target.style.opacity = '0.4'; 
        });
        card.addEventListener('dragend', (e) => {
            e.target.style.opacity = '1.0';
        });
    });

    rhsRails.forEach(rail => {
        const marker = rail.querySelector('.insertion-marker');

        rail.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
            
            const dropX = e.clientX;
            let minDistanceSq = Infinity;
            
            const searchableChildren = Array.from(rail.children).filter(child => child.classList.contains('rhs-card-container'));

            let targetNode = null;
            if (searchableChildren.length === 0) {
                targetNode = marker;
            } else {
                searchableChildren.forEach(child => {
                    const childRect = child.getBoundingClientRect();
                    
                    const childCenterX = childRect.left + childRect.width / 2;
                    const distance = Math.abs(dropX - childCenterX); 

                    if (distance < minDistanceSq) {
                        minDistanceSq = distance;
                        if (dropX < childCenterX) {
                             targetNode = child;
                        } else {
                             targetNode = child.nextElementSibling || marker;
                        }
                    }
                });
                
                if(targetNode === marker && searchableChildren.length > 0) {
                    const lastChild = searchableChildren[searchableChildren.length - 1];
                    const rect = lastChild.getBoundingClientRect();
                    if (dropX > rect.right) {
                         targetNode = marker;
                    } else if (dropX > rect.left + rect.width / 2) {
                         targetNode = marker;
                    } else {
                         targetNode = lastChild;
                    }
                }
            }

            if (targetNode && targetNode.classList.contains('rhs-card-container')) {
                 const rect = targetNode.getBoundingClientRect();
                 marker.style.height = `${rect.height}px`;
                 marker.style.top = `${rect.top - rail.getBoundingClientRect().top}px`;
                 marker.style.left = `${rect.left - rail.getBoundingClientRect().left}px`;
                 marker.style.transform = 'translateX(-100%)';
            } else if (targetNode === marker) {
                if (searchableChildren.length > 0) {
                    const lastChild = searchableChildren[searchableChildren.length - 1];
                    const rect = lastChild.getBoundingClientRect();
                    marker.style.height = `${rect.height}px`;
                    marker.style.top = `${rect.top - rail.getBoundingClientRect().top}px`;
                    marker.style.left = `${rect.right - rail.getBoundingClientRect().left}px`;
                    marker.style.transform = 'translateX(0)';
                } else {
                    marker.style.height = '100%';
                    marker.style.top = '0';
                    marker.style.left = '3px';
                    marker.style.transform = 'translateX(0)';
                }
            }
            marker.style.display = 'block';

        });

        rail.addEventListener('dragleave', () => {
            marker.style.display = 'none';
        });

        rail.addEventListener('drop', (e) => {
            e.preventDefault();
            marker.style.display = 'none';
            const command = e.dataTransfer.getData('text/plain');
            
            if (!command) return;

            const cardToInsert = createCardContainer(command, state.globalAngle);
            const dropX = e.clientX;
            
            let closestChild = null;
            let minDistanceSq = Infinity;
            
            const searchableChildren = Array.from(rail.children).filter(child => child.classList.contains('rhs-card-container'));

            searchableChildren.forEach(child => {
                const childRect = child.getBoundingClientRect();
                const childCenterX = childRect.left + childRect.width / 2;
                
                const distanceSq = Math.pow(dropX - childCenterX, 2); 

                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    closestChild = child;
                }
            });
            
            let targetNode = null;
            
            if (closestChild) {
                const closestRect = closestChild.getBoundingClientRect();
                if (dropX < closestRect.left + closestRect.width / 2) {
                    targetNode = closestChild; 
                } else {
                    targetNode = closestChild.nextElementSibling; 
                }
            } else {
                targetNode = rail.querySelector('.insertion-marker').nextElementSibling;
            }

            if (targetNode === rail.querySelector('.insertion-marker')) {
                rail.insertBefore(cardToInsert, targetNode);
            } else {
                rail.insertBefore(cardToInsert, targetNode);
            }
            
            updatePreview();
            regenerateAndDraw();
            saveHistory();
        });
    });

    // --- 初期化 ---
    loadPreset('koch-curve'); 
    resizeCanvas(); 
});
</script>
    
</body>
</html>