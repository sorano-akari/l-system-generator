<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>カード型 L-システムジェネレータ (ダークモード)</title>
    
    <style>
        /* --- ダークモードのベース --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 10px; 
            background-color: #1e1e1e; 
            color: #d4d4d4; 
        }
        #app-container {
            display: flex;
            flex-direction: column; 
            max-width: 1400px; /* 最大幅を拡大 */
            margin: 0 auto;
            gap: 15px; 
            background-color: #252526; 
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
        }
        
        /* --- メインコンテンツエリア (3ペイン構造に変更) --- */
        #main-content {
            display: flex;
            gap: 15px;
            flex-grow: 1;
        }

        /* 1. 生成規則設定 (左ペイン) - 幅を固定 */
        #rule-editor-container {
            width: 500px; 
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-shrink: 0;
        }

        /* 2. パラメータ/パレット (中央ペイン) - 幅を狭く固定 */
        #controls-and-palette {
            width: 280px; 
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-shrink: 0;
        }

        /* 3. メイン描画エリア (右ペイン) - 残りのスペースを全て使用 */
        #drawing-area-container {
            flex-grow: 1; /* 最大限に拡大 */
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        

        /* --- UIパーツのスタイル --- */
        #rule-editor, #parameters, #palette {
            padding: 12px; 
            border-radius: 6px;
            background-color: #3c3c3c; 
        }

        /* --- コマンドパレット (中央ペイン上部に配置) --- */
        #palette {
            flex-grow: 0; 
            margin-bottom: 0;
        }
        #palette h2 {
            font-size: 1.1em;
            border-bottom: none;
            margin-bottom: 8px;
        }
        #palette-cards {
            display: flex; 
            flex-wrap: wrap; /* ラップして縦に並べる */
            gap: 8px; 
        }

        /* --- プレビューエリア (描画エリアの最下部に移動) --- */
        #preview-area {
            padding: 12px;
            border-radius: 6px;
            background-color: #3c3c3c;
            flex-grow: 0; 
            min-height: 100px;
        }
        #preview-canvas {
            display: block;
            margin-top: 10px;
            border: 1px dashed #5a5a5a;
        }


        /* --- メイン描画エリア (最大限に拡大) --- */
        #main-canvas-wrapper {
            position: relative;
            width: 100%;
            padding-bottom: 75%; /* 4:3のアスペクト比 (横長を強調) */
            height: 0;
            overflow: hidden;
            border: 1px solid #5a5a5a;
            border-radius: 4px;
            flex-grow: 1;
        }
        #main-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            cursor: grab; 
        }
        #main-canvas:active {
            cursor: grabbing;
        }

        /* --- カードのスタイル (アイコンを再導入) --- */
        .card, .lhs-card {
            display: inline-flex;
            flex-shrink: 0; 
            width: 50px; 
            height: 50px; 
            cursor: grab;
            border-radius: 8px;
            font-weight: bold;
            font-size: 0.8em;
            text-align: center;
            user-select: none;
            color: transparent; 
            background-size: 80%; 
            background-position: center;
            background-repeat: no-repeat;
            padding: 4px; 
            background-color: #3c3c3c; 
        }
        .color-green { border: 3px solid #4caf50; } 
        .color-cyan { border: 3px solid #00bcd4; } 
        .color-magenta { border: 3px solid #e91e63; } 
        
        /* ★アイコン画像の再リンク★ */
        .card[data-command="F"], .lhs-card[data-command="F"] { background-image: url('command-f-draw.png'); }
        .card[data-command="f"] { background-image: url('command-f-move.png'); }
        .card[data-command="+"] { background-image: url('command-plus-right.png'); }
        .card[data-command="-"] { background-image: url('command-minus-left.png'); }
        .card[data-command="["], .lhs-card[data-command="["] { background-image: url('command-bracket-push.png'); }
        .card[data-command="]"] { background-image: url('command-bracket-pop.png'); }
        .card[data-command="X"], .lhs-card[data-command="X"] { background-image: url('command-x-variable.png'); }
        .card[data-command="Y"], .lhs-card[data-command="Y"] { background-image: url('command-y-variable.png'); }
        /* ----------------------- */


        /* --- ルール編集エリアのスタイル維持 --- */
        .rule-set { 
            display: flex; 
            align-items: center; 
            margin-bottom: 10px; 
            flex-wrap: wrap;
        }
        .rhs-rail {
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            align-items: center;
            flex-grow: 1;
            min-height: 70px;
            border: 1px dashed #5a5a5a;
            padding: 5px;
            gap: 5px;
            position: relative;
        }
        .rhs-card-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            flex-shrink: 0;
        }
        .card-property {
            width: 40px; 
            font-size: 0.7em;
            text-align: center;
            background-color: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #5a5a5a;
            border-radius: 3px;
            padding: 1px;
        }
        .drop-indicator {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #4caf50;
            display: none;
            z-index: 10;
        }
        
        /* --- その他パーツ --- */
        #depth-controls { display: flex; align-items: center; gap: 5px; margin-bottom: 10px; }
        #generate-reset-buttons { display: flex; justify-content: space-between; gap: 10px; margin-top: 15px; }
        .control-group { margin-top: 10px; padding-top: 10px; border-top: 1px solid #5a5a5a; }
        .zoom-controls { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }

    </style>
</head>
<body>
    <div id="app-container">
        
        <div id="main-content">

            <div id="rule-editor-container">
                <div id="rule-editor">
                    <h2>生成規則設定</h2>
                    
                    <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 15px;">
                        <label for="preset-select">プリセット:</label>
                        <select id="preset-select">
                            <option value="koch">コッホ曲線 (F->F+F-F-F+F, 60°)</option>
                            <option value="sierpinski">シェルピンスキー・ガスケット (F->F-F+F+F-F, 90°)</option>
                            <option value="fern">シダ (X->F[+X][-X], X->F$[-X]+X$, 25°)</option>
                        </select>
                    </div>

                    <div id="editor-buttons">
                        <button id="undo-button">アンドゥ (Undo)</button>
                        <button id="redo-button">リドゥ (Redo)</button>
                        <button id="clear-all-button">全ルールクリア</button>
                        <button id="random-rule-button">ランダムルール生成</button>
                    </div>
                    
                    <label for="axiom-input" style="display: block; margin-top: 10px;">初期値 (Axiom):</label>
                    <input type="text" id="axiom-input" value="F" style="width: 100px; margin-bottom: 10px;">

                    <div class="rule-set">
                        <div class="lhs-card color-green" data-command="F">F</div>
                        <div class="arrow">→</div>
                        <div class="rhs-rail" data-target="F" id="rhs-rail-f">
                            </div>
                    </div>

                    <div class="rule-set">
                        <div class="lhs-card color-cyan" data-command="X">X</div>
                        <div class="arrow">→</div>
                        <div class="rhs-rail" data-target="X" id="rhs-rail-x">
                            </div>
                    </div>
                    
                    <div class="rule-set">
                        <div class="lhs-card color-cyan" data-command="Y">Y</div>
                        <div class="arrow">→</div>
                        <div class="rhs-rail" data-target="Y" id="rhs-rail-y">
                            </div>
                    </div>
                </div>
            </div>
            
            <div id="controls-and-palette">
                
                <div id="palette">
                    <h2>コマンドパレット (Drag me!)</h2>
                    <div id="palette-cards">
                        <div class="card color-green" data-command="F">F</div>
                        <div class="card color-green" data-command="+" data-angle="60">+</div>
                        <div class="card color-green" data-command="-" data-angle="60">-</div>
                        <div class="card color-magenta" data-command="f">f</div>
                        <div class="card color-magenta" data-command="]">]</div>
                        <div class="card color-cyan" data-command="[">[</div>
                        <div class="card color-cyan" data-command="X">X</div>
                        <div class="card color-cyan" data-command="Y">Y</div>
                    </div>
                </div>

                <div id="parameters">
                    <h3>描画パラメータ</h3>
                    <label for="depth">世代 (Depth):</label>
                    <div id="depth-controls">
                        <button id="depth-down">▼</button>
                        <span id="depth-value">2</span>
                        <button id="depth-up">▲</button>
                    </div>
                    
                    <label for="angle">グローバル回転角 ($\delta$):</label>
                    <input type="range" id="angle-slider" min="1" max="180" value="60" step="0.1" style="width: 100%;">
                    <input type="number" id="angle-input" min="1" max="180" value="60" step="0.1" style="width: 80px;">
                    <button id="sync-angle-button">全カードに適用</button>
                    
                    <div class="depth-color-option" style="margin-top: 10px;">
                        <input type="checkbox" id="color-by-depth" checked>
                        <label for="color-by-depth">世代ごとに色分け</label>
                    </div>
                    <div class="depth-color-option">
                        <input type="checkbox" id="keep-drawing">
                        <label for="keep-drawing">前の世代を残像表示</label>
                    </div>
                    
                    <div class="control-group">
                        <h3>ズーム &amp; パン</h3>
                        <label for="zoom-slider">ズーム倍率 (<span id="zoom-value">1.0</span>x):</label>
                        <div class="zoom-controls">
                            <input type="range" id="zoom-slider" min="0.1" max="10" value="1" step="0.1" style="flex-grow: 1;">
                            <button id="zoom-reset-button">リセット</button>
                        </div>
                        <div style="font-size: 0.8em; margin-top: 5px;">
                            (ドラッグで移動できます)
                            <button id="pan-reset-button" style="padding: 2px 8px;">中央に戻す</button>
                        </div>
                    </div>

                    <div id="generate-reset-buttons">
                        <button id="generate-button">生成 &amp; 描画</button>
                        <button id="reset-drawing-button" style="background-color: #5a5a5a;">描画リセット</button>
                    </div>
                </div>
            </div>

            <div id="drawing-area-container">
                <div id="drawing-area">
                    <h2>メイン描画 (世代: <span id="main-depth-display">2</span>)</h2>
                    <div id="main-canvas-wrapper">
                        <canvas id="main-canvas"></canvas>
                    </div>
                </div>
                <div id="preview-area">
                    <h3>1世代プレビュー (F → ...)</h3>
                    <canvas id="preview-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // ===========================================
            // I. 状態管理と初期化
            // ===========================================
            const HISTORY_LIMIT = 20;
            const history = [];
            let historyIndex = -1;
            
            const state = {
                depth: 2,
                globalAngle: 60, 
                rules: { 'X': '', 'F': 'F+(60)F-(60)F-(60)F+(60)F', 'Y': '' }, 
                colorPalette: [
                    '#4caf50', '#2196f3', '#ffc107', '#e91e63', '#00bcd4', 
                    '#ff9800', '#9c27b0', '#03a9f4', '#8bc34a', '#ff5722'
                ],
                angleCommands: ['+', '-'],
                zoom: 1.0,           
                panX: 0,             
                panY: 0              
            };
            
            let draggedElement = null;
            let isMoving = false; 

            // パン操作用の変数
            let isDraggingCanvas = false;
            let lastMouseX = 0;
            let lastMouseY = 0;

            const mainCanvas = document.getElementById('main-canvas');
            const previewCanvas = document.getElementById('preview-canvas');

            // 描画エリアのサイズをDOM要素から取得してcanvasに適用
            function resizeCanvas() {
                const mainWrapper = document.getElementById('main-canvas-wrapper');
                const prevWrapper = document.getElementById('preview-area');
                
                mainCanvas.width = mainWrapper.clientWidth;
                mainCanvas.height = mainWrapper.clientHeight; 
                
                // プレビューキャンバスの幅を親要素の幅に合わせる
                previewCanvas.width = prevWrapper.clientWidth - 24; 
                previewCanvas.height = 100; // 高さは固定値
                
                if (history.length > 0) {
                    document.getElementById('generate-button').click();
                } else {
                    updatePreview();
                }
            }
            window.addEventListener('resize', resizeCanvas);


            const mainCtx = mainCanvas.getContext('2d');
            const previewCtx = previewCanvas.getContext('2d');
            
            const depthValueSpan = document.getElementById('depth-value');
            const mainDepthDisplay = document.getElementById('main-depth-display');
            const angleSlider = document.getElementById('angle-slider');
            const angleInput = document.getElementById('angle-input');
            const rhsRails = Array.from(document.querySelectorAll('.rhs-rail'));

            const zoomSlider = document.getElementById('zoom-slider');
            const zoomValueSpan = document.getElementById('zoom-value');

            // ===========================================
            // II. UIコントロールとパラメータ更新 (維持)
            // ===========================================
            
            const updateDepth = (newDepth) => {
                state.depth = Math.min(Math.max(newDepth, 0), 12);
                depthValueSpan.textContent = state.depth;
                mainDepthDisplay.textContent = state.depth;
                document.getElementById('generate-button').click();
            };
            document.getElementById('depth-up').addEventListener('click', () => updateDepth(state.depth + 1));
            document.getElementById('depth-down').addEventListener('click', () => updateDepth(state.depth - 1));

            const updateAngle = (value) => {
                state.globalAngle = parseFloat(value);
                angleSlider.value = state.globalAngle;
                angleInput.value = state.globalAngle;
                updatePreview();
                document.getElementById('generate-button').click();
            };
            angleSlider.addEventListener('input', (e) => updateAngle(e.target.value));
            angleInput.addEventListener('change', (e) => updateAngle(e.target.value));

            document.getElementById('sync-angle-button').addEventListener('click', () => {
                rhsRails.forEach(rail => {
                    rail.querySelectorAll('.card[data-angle]').forEach(card => {
                        const input = card.parentNode.querySelector('.card-property');
                        if (input) {
                            input.value = state.globalAngle;
                            card.dataset.angle = state.globalAngle;
                        }
                    });
                });
                saveHistory(); 
                updatePreview();
                document.getElementById('generate-button').click();
            });
            
            document.getElementById('axiom-input').addEventListener('change', () => {
                saveHistory();
                document.getElementById('generate-button').click();
            });
            
            document.getElementById('reset-drawing-button').addEventListener('click', () => {
                mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
                mainDepthDisplay.textContent = '---'; 
            });

            // ズーム操作の処理
            const updateZoom = (value) => {
                state.zoom = parseFloat(value);
                zoomSlider.value = state.zoom;
                zoomValueSpan.textContent = state.zoom.toFixed(1);
                document.getElementById('generate-button').click();
            };

            zoomSlider.addEventListener('input', (e) => updateZoom(e.target.value));
            document.getElementById('zoom-reset-button').addEventListener('click', () => {
                updateZoom(1.0);
                document.getElementById('pan-reset-button').click(); 
            });

            // パンリセットボタンの処理
            document.getElementById('pan-reset-button').addEventListener('click', () => {
                state.panX = 0;
                state.panY = 0;
                document.getElementById('generate-button').click();
            });

            // パン操作 (マウスドラッグ) の処理
            mainCanvas.addEventListener('mousedown', (e) => {
                isDraggingCanvas = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                mainCanvas.style.cursor = 'grabbing';
            });

            mainCanvas.addEventListener('mousemove', (e) => {
                if (!isDraggingCanvas) return;
                
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                state.panX += deltaX;
                state.panY += deltaY;

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                document.getElementById('generate-button').click();
            });

            mainCanvas.addEventListener('mouseup', () => {
                isDraggingCanvas = false;
                mainCanvas.style.cursor = 'grab';
            });
            
            mainCanvas.addEventListener('mouseleave', () => {
                isDraggingCanvas = false;
                mainCanvas.style.cursor = 'grab';
            });
            
            // ===========================================
            // III. プリセット機能 (維持)
            // ===========================================
            const presets = {
                koch: { axiom: 'F', rules: { F: 'F+(60)F-(60)F-(60)F+(60)F', X: '', Y: '' }, angle: 60 },
                sierpinski: { axiom: 'F', rules: { F: 'F-(90)F+(90)F+(90)F-(90)F', X: '', Y: '' }, angle: 90 },
                fern: { axiom: 'X', rules: { F: 'FF', X: 'F[+(25)X][-(25)X]F[-(25)X]+(25)X', Y: '' }, angle: 25 }
            };
            
            function applyRulesToRail(railElement, ruleString, defaultAngle) {
                railElement.innerHTML = '';
                const tokens = ruleString.match(/([+\-])\(\d+(\.\d+)?\)|[FXfY[\]+\-]/g) || [];
                
                tokens.forEach(token => {
                    let command = token;
                    let angle = defaultAngle;

                    const angleMatch = token.match(/^([+\-])\((\d+(\.\d+)?)\)$/);
                    if (angleMatch) {
                        command = angleMatch[1];
                        angle = angleMatch[2];
                    }

                    const container = createCardContainer(command, angle);
                    railElement.appendChild(container);
                });
            }

            function applyPreset(presetName) {
                const preset = presets[presetName];
                if (!preset) return;

                document.getElementById('axiom-input').value = preset.axiom;
                updateAngle(preset.angle); 
                
                const railF = document.getElementById('rhs-rail-f');
                const railX = document.getElementById('rhs-rail-x');
                const railY = document.getElementById('rhs-rail-y'); 
                
                applyRulesToRail(railF, preset.rules.F || '', preset.angle);
                applyRulesToRail(railX, preset.rules.X || '', preset.angle);
                applyRulesToRail(railY, preset.rules.Y || '', preset.angle);

                saveHistory();
                updatePreview();
                document.getElementById('generate-button').click();
            }
            
            document.getElementById('preset-select').addEventListener('change', (e) => {
                applyPreset(e.target.value);
            });

            // ===========================================
            // IV. カード/履歴/ルールロジック (維持)
            // ===========================================
            
            function getCardColorClass(command) {
                if (command === 'F' || command === '+' || command === '-') return 'color-green';
                if (command === '[' || command === 'X' || command === 'Y') return 'color-cyan';
                if (command === 'f' || command === ']') return 'color-magenta';
                return '';
            }
            
            function createCardContainer(command, angle) {
                const container = document.createElement('div');
                container.classList.add('rhs-card-container');
                container.setAttribute('draggable', true); 
                
                const card = document.createElement('div');
                card.classList.add('card', getCardColorClass(command));
                card.textContent = command;
                card.dataset.command = command;
                card.style.cursor = 'grab';
                
                container.appendChild(card);
                
                if (state.angleCommands.includes(command)) {
                    card.dataset.angle = angle || state.globalAngle;
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.classList.add('card-property');
                    input.value = card.dataset.angle;
                    input.min = 1; input.max = 180; input.step = 0.1;
                    
                    input.addEventListener('change', (e) => {
                        card.dataset.angle = e.target.value;
                        saveHistory(); 
                        updatePreview();
                        document.getElementById('generate-button').click();
                    });
                    container.appendChild(input);
                }

                container.addEventListener('dblclick', () => { container.remove(); saveHistory(); updatePreview(); document.getElementById('generate-button').click(); });
                
                // (D&Dイベントリスナーは省略... 変更なし)
                
                return container;
            }
            
            // ... (D&Dロジック, 履歴ロジック, ルール取得ロジックは維持 - 省略) ...
            function saveHistory() { /* ... */ }
            function loadHistory(index) { /* ... */ }
            function updateUndoRedoButtons() { /* ... */ }

            document.getElementById('undo-button').addEventListener('click', () => loadHistory(historyIndex - 1));
            document.getElementById('redo-button').addEventListener('click', () => loadHistory(historyIndex + 1));
            document.getElementById('clear-all-button').addEventListener('click', () => {
                rhsRails.forEach(rail => rail.innerHTML = '');
                document.getElementById('axiom-input').value = 'F';
                saveHistory();
                updatePreview();
                document.getElementById('generate-button').click();
            });

            function getCurrentRules() { 
                const rules = {};
                rhsRails.forEach(rail => {
                    const target = rail.dataset.target; 
                    let rhsString = '';
                    Array.from(rail.querySelectorAll('.card')).forEach(card => {
                        const command = card.dataset.command;
                        let angle = card.dataset.angle;
                        if (state.angleCommands.includes(command)) {
                            rhsString += `${command}(${angle})`;
                        } else {
                            rhsString += command;
                        }
                    });
                    if (target) { rules[target] = rhsString; }
                });
                return rules;
            }

            function generateLSystemWithDepth(axiom, rules, iterations) { 
                let currentStrings = [axiom];
                let allStrings = [axiom];
                for (let i = 0; i < iterations; i++) {
                    let nextString = '';
                    for (const char of currentStrings[i]) {
                        if (Object.prototype.hasOwnProperty.call(rules, char)) { nextString += rules[char]; } 
                        else { nextString += char; }
                    }
                    currentStrings.push(nextString);
                    allStrings.push(nextString);
                }
                return allStrings;
            }

            // V. オートスケールとバウンディングボックス計算 (維持)
            function getLSystemBounds(lSystemString, globalAngle) {
                let x = 0;
                let y = 0;
                let currentAngle = -90; 
                const stateStack = [];

                let minX = 0, maxX = 0, minY = 0, maxY = 0;
                const lineLength = 1; 

                for (let i = 0; i < lSystemString.length; i++) {
                    const command = lSystemString[i];
                    let turnAngle = globalAngle; 

                    if (state.angleCommands.includes(command)) {
                        const angleMatch = lSystemString.substring(i).match(/^([+\-])\((\d+(\.\d+)?)\)/);
                        if (angleMatch) {
                            turnAngle = parseFloat(angleMatch[2]);
                            i += angleMatch[0].length - 1; 
                        }
                    }

                    switch (command) {
                        case 'F': 
                        case 'f': 
                            const dx = lineLength * Math.cos(currentAngle * Math.PI / 180);
                            const dy = lineLength * Math.sin(currentAngle * Math.PI / 180);
                            x += dx;
                            y += dy;
                            
                            minX = Math.min(minX, x);
                            maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y);
                            maxY = Math.max(maxY, y);
                            break;
                        case '+': currentAngle += turnAngle; break;
                        case '-': currentAngle -= turnAngle; break;
                        case '[': stateStack.push({ x, y, angle: currentAngle }); break;
                        case ']': 
                            const stateRestored = stateStack.pop();
                            if (stateRestored) {
                                x = stateRestored.x;
                                y = stateRestored.y;
                                currentAngle = stateRestored.angle;
                            }
                            break;
                    }
                }

                return {
                    width: maxX - minX,
                    height: maxY - minY,
                    minX: minX,
                    minY: minY
                };
            }


            // VI. ズームとパンを考慮した描画ロジックに修正 (維持)
            function drawLSystem(ctx, lSystemStrings, isMainCanvas) { 
                const iterations = lSystemStrings.length - 1;
                
                if (!isMainCanvas) {
                    const previewString = lSystemStrings[iterations];
                    const bounds = getLSystemBounds(previewString, state.globalAngle);
                    
                    const startX = ctx.canvas.width / 2;
                    const startY = ctx.canvas.height - 10;
                    
                    const targetWidth = ctx.canvas.width * 0.9;
                    const targetHeight = ctx.canvas.height * 0.9;
                    let autoScale = 1.0;
                    if (bounds.width > 0 && bounds.height > 0) {
                         autoScale = Math.min(targetWidth / bounds.width, targetHeight / bounds.height);
                    }
                    
                    performDrawing(ctx, lSystemStrings, isMainCanvas, autoScale, 0, 0, startX, startY, bounds);
                    return;
                }

                // --- メインキャンバスのオートスケール処理 ---
                const lSystemString = lSystemStrings[iterations];
                const bounds = getLSystemBounds(lSystemString, state.globalAngle);
                
                const targetRatio = 0.8; 
                const targetWidth = mainCanvas.width * targetRatio;
                const targetHeight = mainCanvas.height * targetRatio;
                
                let autoScale = 1.0;
                if (bounds.width > 0 && bounds.height > 0) {
                     autoScale = Math.min(targetWidth / bounds.width, targetHeight / bounds.height);
                } else {
                    autoScale = 1.0; 
                }
                
                // パン計算 (中心に配置)
                const autoPanX = mainCanvas.width / 2 - (bounds.width * autoScale) / 2 - bounds.minX * autoScale;
                const autoPanY = mainCanvas.height / 2 - (bounds.height * autoScale) / 2 - bounds.minY * autoScale;

                const startBaseX = 0; 
                const startBaseY = 0;

                const finalZoom = autoScale * state.zoom;
                const finalPanX = autoPanX + state.panX;
                const finalPanY = autoPanY + state.panY;
                
                performDrawing(ctx, lSystemStrings, isMainCanvas, finalZoom, finalPanX, finalPanY, startBaseX, startBaseY, bounds);
            }

            // 実際の描画を実行するコア関数 (維持)
            function performDrawing(ctx, lSystemStrings, isMainCanvas, scale, panX, panY, startBaseX, startBaseY, bounds) {
                const iterations = lSystemStrings.length - 1;
                const colorByDepth = document.getElementById('color-by-depth').checked;
                const keepDrawing = document.getElementById('keep-drawing').checked;

                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); 
                
                const startDepth = keepDrawing && isMainCanvas ? 0 : iterations;
                
                for (let depth = startDepth; depth <= iterations; depth++) {
                    const lSystemString = lSystemStrings[depth];
                    
                    let x = startBaseX;
                    let y = startBaseY;
                    let currentAngle = -90; 
                    const stateStack = [];

                    ctx.lineWidth = Math.min(2, 1 / scale) * (isMainCanvas ? 1 : 0.5); 

                    if (colorByDepth && isMainCanvas) {
                        ctx.strokeStyle = state.colorPalette[depth % state.colorPalette.length];
                    } else if (isMainCanvas) {
                        ctx.strokeStyle = 'white'; 
                    } else {
                        ctx.strokeStyle = 'red'; 
                    }
                    
                    if (keepDrawing && isMainCanvas && depth < iterations) {
                        ctx.globalAlpha = 0.2 + (0.8 / iterations) * depth; 
                    } else {
                        ctx.globalAlpha = 1.0;
                    }

                    ctx.beginPath();
                    // オートスケール・パン適用後の開始点
                    ctx.moveTo(startBaseX * scale + panX, startBaseY * scale + panY); 
                    
                    for (let i = 0; i < lSystemString.length; i++) {
                        const command = lSystemString[i];
                        let turnAngle = state.globalAngle; 

                        if (state.angleCommands.includes(command)) {
                            const angleMatch = lSystemString.substring(i).match(/^([+\-])\((\d+(\.\d+)?)\)/);
                            if (angleMatch) {
                                turnAngle = parseFloat(angleMatch[2]);
                                i += angleMatch[0].length - 1; 
                            }
                        }

                        switch (command) {
                            case 'F': 
                            case 'f': 
                                const lineLength = 1 * scale;
                                
                                const dx = lineLength * Math.cos(currentAngle * Math.PI / 180);
                                const dy = lineLength * Math.sin(currentAngle * Math.PI / 180);
                                const newX = x + dx;
                                const newY = y + dy;
                                
                                if (command === 'F') {
                                    ctx.lineTo(newX + panX, newY + panY);
                                    ctx.stroke();
                                    ctx.beginPath();
                                    ctx.moveTo(newX + panX, newY + panY);
                                } else {
                                    ctx.moveTo(newX + panX, newY + panY);
                                }
                                x = newX;
                                y = newY;
                                break;
                            case '+': currentAngle += turnAngle; break;
                            case '-': currentAngle -= turnAngle; break;
                            case '[': stateStack.push({ x, y, angle: currentAngle }); break;
                            case ']': 
                                const stateRestored = stateStack.pop();
                                if (stateRestored) {
                                    x = stateRestored.x;
                                    y = stateRestored.y;
                                    currentAngle = stateRestored.angle;
                                    ctx.beginPath();
                                    ctx.moveTo(x + panX, y + panY); 
                                }
                                break;
                        }
                    }
                }
            }


            // --- 描画トリガー関数 ---
            function updatePreview() {
                const axiom = document.getElementById('axiom-input').value;
                state.rules = getCurrentRules();
                const lSystemStrings = generateLSystemWithDepth(axiom, state.rules, 1);
                drawLSystem(previewCtx, lSystemStrings, false);
            }
            
            document.getElementById('generate-button').addEventListener('click', () => {
                const axiom = document.getElementById('axiom-input').value;
                const iterations = state.depth;
                state.rules = getCurrentRules();
                
                mainDepthDisplay.textContent = iterations;
                const lSystemStrings = generateLSystemWithDepth(axiom, state.rules, iterations);
                drawLSystem(mainCtx, lSystemStrings, true);
            });
            
            document.getElementById('color-by-depth').addEventListener('change', () => {
                document.getElementById('generate-button').click();
            });
            document.getElementById('keep-drawing').addEventListener('change', () => {
                document.getElementById('generate-button').click();
            });


            // --- 初期実行 ---
            // D&Dロジックの再設定 (省略された部分)
            document.querySelectorAll('#palette-cards .card').forEach(card => {
                card.setAttribute('draggable', true);
                card.addEventListener('dragstart', (e) => {
                    draggedElement = createCardContainer(e.target.dataset.command, e.target.dataset.angle);
                    isMoving = false;
                    e.dataTransfer.effectAllowed = 'copy';
                });
                card.addEventListener('dragend', () => {
                    draggedElement = null;
                    isMoving = false;
                });
            });

            rhsRails.forEach(rail => {
                // ドロップゾーンの処理 (省略された部分)
            });

            resizeCanvas(); 
            zoomValueSpan.textContent = state.zoom.toFixed(1);
            applyPreset('koch'); 
        });
    </script>
</body>
</html>